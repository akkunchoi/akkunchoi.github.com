<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>akkunchoi.github.com</title>
        <link>http://akkunchoi.github.com</link>
        <atom:link href="http://akkunchoi.github.com/rss.xml" rel="self" type="application/rss+xml" />
        <description>This site is a information for development written by akkunchoi</description>
        <pubDate>Fri, 11 Jan 2013 17:14:37 +0900</pubDate>
        <lastBuildDate>Fri, 11 Jan 2013 17:14:37 +0900</lastBuildDate>
        
        <item>
            <title>MacOSX ショートカット</title>
            <description>&lt;p&gt;ショートカットがなかなか覚えられない。使いたい・使いそうなものだけをピックアップ。&lt;/p&gt;

&lt;p&gt;環境は MacBook Snow Leopard です。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;起動(起動したらすぐに押し続ける)&lt;/h2&gt;

&lt;p&gt;セーフモードで起動するとキャッシュなどを削除するので月に一度は実行すると良いらしい。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Option&lt;/td&gt;
      &lt;td&gt;スタートアップマネージャーを起動して、起動ディスクを選択する&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift&lt;/td&gt;
      &lt;td&gt;セーフモード&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;CD,DVDから起動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + S&lt;/td&gt;
      &lt;td&gt;シングルユーザーモードで起動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Eject or マウスボタン or トラックパッドボタン&lt;/td&gt;
      &lt;td&gt;強制的にリムーバブルディスク（CD・DVD）を取り出す&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;スリープ、再起動、ログアウト、電源&lt;/h2&gt;

&lt;p&gt;強制再起動はどうすることもできなくなる時に使える。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Option + Eject&lt;/td&gt;
      &lt;td&gt;すぐにスリープ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Control + Eject&lt;/td&gt;
      &lt;td&gt;アプリケーションを終了してから再起動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Control + Eject&lt;/td&gt;
      &lt;td&gt;強制再起動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Option + Shift + Q&lt;/td&gt;
      &lt;td&gt;ログアウト（確認なし）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Option + Shift + Esc (長押し)&lt;/td&gt;
      &lt;td&gt;最前面のアプリケーションを強制終了&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Option + Esc&lt;/td&gt;
      &lt;td&gt;「強制終了」ダイアログを表示&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-2&quot;&gt;ウィンドウ&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + F1&lt;/td&gt;
      &lt;td&gt;同じアプリの次のウィンドウ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Command + [F9-F12]&lt;/td&gt;
      &lt;td&gt;Spaces 切り替え&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + F5&lt;/td&gt;
      &lt;td&gt;Voice over&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Esc&lt;/td&gt;
      &lt;td&gt;Front Row&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + H&lt;/td&gt;
      &lt;td&gt;アクティブアプリケーションを隠す&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + ,&lt;/td&gt;
      &lt;td&gt;アプリケーションの環境設定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Control + F2&lt;/td&gt;
      &lt;td&gt;メニューバーにフォーカス&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Control + F4&lt;/td&gt;
      &lt;td&gt;次のウィンドウに移動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Control + F6&lt;/td&gt;
      &lt;td&gt;フローティングウィンドウに移動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Control + F8&lt;/td&gt;
      &lt;td&gt;メニューバーのメニューステータス（右上のやつ）へのフォーカス&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + ` (+ Shift)&lt;/td&gt;
      &lt;td&gt;アプリケーション内の次（前）のウィンドウに移動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Option + T&lt;/td&gt;
      &lt;td&gt;記号パレットの表示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Shift + ] (or [ )&lt;/td&gt;
      &lt;td&gt;次（前）のタブに移動&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-3&quot;&gt;キャプチャ&lt;/h2&gt;

&lt;p&gt;普段 &lt;a href=&quot;http://www.apple.com/downloads/dashboard/business/screenshotplus.html&quot;&gt;Screenshot Plus&lt;/a&gt; という Dashboard を使うので全く覚えられない。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Shift + 3&lt;/td&gt;
      &lt;td&gt;全画面キャプチャ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Shift + 4&lt;/td&gt;
      &lt;td&gt;矩形キャプチャ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command + Shift + 4 その後に Space&lt;/td&gt;
      &lt;td&gt;ウィンドウキャプチャ&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-4&quot;&gt;任意のアプリケーションのショートカットキーを変更する&lt;/h2&gt;

&lt;p&gt;iTerm の “Toggle Full Screen” が Command + Enter で起動してしまって誤操作が多いので、別のショートカットキーに変更します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/posts/mac-shortcut-menu-before.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;変更したいショートカットのメニュー名を確認しておきます。&lt;/p&gt;

&lt;p&gt;システム環境設定 &amp;gt; キーボード &amp;gt; キーボードショートカット &amp;gt; アプリケーション で + を押して設定を追加します。&lt;/p&gt;

&lt;p&gt;アプリケーションを指定、メニュー名を入力、書き換えたいショートカットキーを入力します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/posts/mac-shortcut-systempref.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iTermのメニューバーを見ると、確かに変更されていますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/posts/mac-shortcut-menu-after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://inforati.jp/apple/mac-tips-techniques/system-hints/how-to-start-up-reboot-shutdown-sleep-logout-with-mac-keyboard-shortcut.html&quot;&gt;http://inforati.jp/apple/mac-tips-techniques/system-hints/how-to-start-up-reboot-shutdown-sleep-logout-with-mac-keyboard-shortcut.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/goinger/20090101/1230808275&quot;&gt;http://d.hatena.ne.jp/goinger/20090101/1230808275&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-11-19 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/macbook-shortcut.html</link>
        </item>
        
        <item>
            <title>Rails 3.2 tips</title>
            <description>&lt;h2 id=&quot;assets&quot;&gt;assetsのログを消したい&lt;/h2&gt;

&lt;p&gt;こういうのが大量にでるので消したい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Started GET &quot;/assets/jquery_ujs.js?body=1&quot; for 127.0.0.1 at 2012-11-13 19:41:17 +0900
Served asset /jquery_ujs.js - 304 Not Modified (0ms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;initializerを追加して無理やりなんとかする。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/initializers/quiet_assets.rb
Rails.application.assets.logger = Logger.new('/dev/null')
Rails::Rack::Logger.class_eval do
  def call_with_quiet_assets(env)
    previous_level = Rails.logger.level
    Rails.logger.level = Logger::ERROR if env['PATH_INFO'].index(&quot;/assets/&quot;) == 0
    call_without_quiet_assets(env).tap do
      Rails.logger.level = previous_level
    end
  end
  alias_method_chain :call, :quiet_assets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.yabasoft.biz/archives/3905&quot;&gt;http://blog.yabasoft.biz/archives/3905&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;warn--could-not-determine-content-length-of-response-body-set-content-length-of-the-response-or-set-responsechunked--true&quot;&gt;WARN  Could not determine content-length of response body. Set content-length of the response or set Response#chunked = true&lt;/h2&gt;

&lt;p&gt;なぜかたくさん出る警告。これはWEBrickの問題らしい。&lt;/p&gt;

&lt;p&gt;ということで thin を入れた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Gemfile
gem 'thin'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WEBrickだと頻繁に落ちることがあったが、それも thin で解決した。&lt;/p&gt;

&lt;h2 id=&quot;applicationcss-isnt-precompiled&quot;&gt;application.css isn’t precompiled&lt;/h2&gt;

&lt;p&gt;Productionで出現したエラー。&lt;/p&gt;

&lt;p&gt;よくわかってないが、productionの設定を変更して解決した。asset pipelineの恩恵受けたい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# config/environments/production.rb
config.assets.compile = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変更後は再起動を忘れずに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch tmp/restart.txt
&lt;/code&gt;&lt;/pre&gt;

</description>
            <published>2012-11-13 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/rails3.2-tips.html</link>
        </item>
        
        <item>
            <title>Coffeescript</title>
            <description>&lt;p&gt;JavaScripter が &lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt; に移行する際の要点をまとめ。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;関数定義は -&amp;gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;function&lt;/code&gt; と &lt;code&gt;{&lt;/code&gt; と &lt;code&gt;}&lt;/code&gt; は消します。代わりに &lt;code&gt;-&amp;gt;&lt;/code&gt; を入れます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt; // javascript
var square;
square = function(x) {
      return x * x;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code data-language=&quot;coffeescript&quot;&gt; # coffeescript
square = (x) -&amp;gt; x * x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;タイプ数減りますね。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;クラス定義&lt;/h2&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt; // javascript
var Animal;
Animal = (function() {

  function Animal(name) {
    this.name = name;
  }

  Animal.prototype.move = function(meters) {
    return alert(this.name + (&quot; moved &quot; + meters + &quot;m.&quot;));
  };

  return Animal;

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code data-language=&quot;coffeescript&quot;&gt; # coffeescript
class Animal
  constructor: (@name) -&amp;gt;

  move: (meters) -&amp;gt;
    alert @name + &quot; moved #{meters}m.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラスの定義方法を統一させることができるのは良いかも。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@name&lt;/code&gt; は ruby の インスタンス変数のような感じです。
しかし、&lt;code&gt;constructor: (@name) -&amp;gt;&lt;/code&gt; この一行で &lt;code&gt;this.name&lt;/code&gt; にセットされるのはなんだかキモいです。&lt;/p&gt;

&lt;p&gt;継承もできます。&lt;/p&gt;

&lt;h2 id=&quot;this-&quot;&gt;thisの束縛は =&amp;gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt; // javascript
var _this = this;
$.each([1, 2, 3, 4, 5], function(k, v) {
  _this.moge(v);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code data-language=&quot;coffeescript&quot;&gt; # coffeescript
$.each [1,2,3,4,5], (k,v) =&amp;gt;
  this.moge(v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう &lt;code&gt;var self = this;&lt;/code&gt; なんて書かなくて良い！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;関数呼び出しは、引数がある場合は（）を省略可能&lt;/h2&gt;

&lt;p&gt;Rubyのノリです。&lt;/p&gt;

&lt;p&gt;ただし、引数がない関数の場合は &lt;code&gt;()&lt;/code&gt; が必要（プロパティ呼び出しと区別がつかないからだろう）。&lt;/p&gt;

&lt;h2 id=&quot;return&quot;&gt;最後の式はreturnする&lt;/h2&gt;

&lt;p&gt;Rubyのノリです。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;インデント重要&lt;/h2&gt;

&lt;p&gt;Pythonのノリです。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;その他&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;セミコロンは不要。あってもエラーにはならない&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-11-13 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/coffeescript.html</link>
        </item>
        
        <item>
            <title>jQuery Deferred and $(document).ready()</title>
            <description>&lt;p&gt;&lt;code&gt;$(document).ready()&lt;/code&gt;の後にajaxリクエストすると、レンダリング中にムダに待機してしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt;$(document).ready(function(){
  $.ajax('contents', function(response){
    // process
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ready()&lt;/code&gt;内ではなく、外でajaxリクエストすれば真っ先にリクエストできます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt;$.ajax('contents', function(response){
  // process?
});
$(document).ready(function(){
  // process?
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこれでは ajax リクエストの完了と ready になった後に実行するというのが難しくなります。無理やり実装するならばこんな感じでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt;var ajaxDone = false, ready = false;
$.ajax('contents', function(response){
  if (ready){
    // process
  }
  ajaxDone = true;
});
$(document).ready(function(){
  if (ajaxDone){
    // process
  }
  ready = true;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;カッコ悪いですし、ajaxリクエストが増えた場合に面倒ですね。&lt;/p&gt;

&lt;p&gt;このようなコールバックのフローを上手く扱うには &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;jQuery.Deferred&lt;/a&gt; を使います。この場合、次のように記述することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;javascript&quot;&gt;var ready = $.Deferred();
$(document).ready(ready.resolve);
$.when(ready, $.ajax('contents')).then(function($, response) {
  // process
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考: &lt;a href=&quot;http://stackoverflow.com/questions/6177187/can-i-get-a-jquery-deferred-on-document-ready&quot;&gt;http://stackoverflow.com/questions/6177187/can-i-get-a-jquery-deferred-on-document-ready&lt;/a&gt;&lt;/p&gt;

</description>
            <published>2012-10-31 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/jquery-deferred-and-document-ready.html</link>
        </item>
        
        <item>
            <title>Git サブプロジェクトの切り出し</title>
            <description>&lt;p&gt;サブプロジェクトを切り出して、リポジトリを分割する方法。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;サブプロジェクトの切り出し&lt;/h2&gt;

&lt;p&gt;あらかじめサブプロジェクトを subproject_dir ディレクトリにまとめておきます。&lt;/p&gt;

&lt;p&gt;サブプロジェクトから、ブランチを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git subtree split -P subproject_dir -b subproject_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subproject_branch に今までの履歴込でブランチが作成されました。ただし、&lt;strong&gt;切り出し元とは共通の祖先はありません&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;別のリポジトリにしたいならリモート指定すれば良いし、subtreeで管理してもいい。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;切り出したサブプロジェクトを削除&lt;/h2&gt;

&lt;p&gt;切り出し元からサブプロジェクトを完全に削除するならもう一手間いります。&lt;/p&gt;

&lt;p&gt;切り出し元の方で subproject_dir を削除します。これは&lt;strong&gt;歴史改変&lt;/strong&gt;を行います。超危険コマンドです。関係者の同意のもと行なって下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git filter-branch --tree-filter 'rm -rf subproject_dir' HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで subproject_dir に関する変更は今までの履歴も含めて削除されます。&lt;/p&gt;

&lt;p&gt;歴史改変された master はそのままでは push できません。
push するとこんなこと言われます。
（オプションで削除できるようにすることもできるみたい）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt; ! [remote rejected] master (deletion of the current branch prohibited)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;filter-branch 後の状態でブランチを切っておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git co -b filtered
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;master はresetして巻き戻します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --hard {最初のコミットまで戻す}
git push -f origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで巻き戻せました。
filter-branch 後の結果を master にマージします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git merge filtered
&lt;/code&gt;&lt;/pre&gt;

</description>
            <published>2012-10-26 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/git-split-subproject.html</link>
        </item>
        
        <item>
            <title>Git 空ブランチ (Orphan branch)</title>
            <description>&lt;h2 id=&quot;section&quot;&gt;空ブランチ&lt;/h2&gt;

&lt;p&gt;Gitではコミットやブランチを作成する場合、必ず親を指定する必要があります。今までの歴史を全て辿れるようにするためです。&lt;/p&gt;

&lt;p&gt;空ブランチを作成すると、今までの歴史とは全く別の新たな歴史を、同じリポジトリ内で開始することができます。&lt;/p&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;作成方法１: Github pagesの場合&lt;/h2&gt;

&lt;p&gt;Github pages ではプロジェクトサイトを作成する際にはプロジェクトのリポジトリ内で空ブランチを作成します。
空ブランチを使う理由はわかりませんが、プロジェクト本体には影響させず、リポジトリ内に同梱させるためにこの手法を採用したのだと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# HEADをnew_branchに切り替える。
git symbolic-ref HEAD refs/heads/new_branch

# symbolic-refを直接変更した場合はインデックスとワーキングツリーが残るので削除する
rm .git/index
git clean -fdx

# new_branchの内容をコミット
touch .gitignore
git add .
git commit
git push -u origin new_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/kanonji/20110221/1298263044&quot;&gt;各コマンドの意味はこちらを参考にしました&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;orphan&quot;&gt;作成方法２: orphanオプション&lt;/h2&gt;

&lt;p&gt;Git 1.7.2 では checkout に orphan オプションがが追加されました。これで、空ブランチ（orphan branch）が簡単に作成できるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout --orphan new_branch_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;orphan とは孤児のことです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://irohiroki.com/2010/08/02/push-orphan-to-heroku&quot;&gt;http://irohiroki.com/2010/08/02/push-orphan-to-heroku&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;空ブランチの用途&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html&quot;&gt;git-checkout&lt;/a&gt; によると、全履歴を見せずにツリーを公開したい場合や、公開すべきでないコードが履歴に含まれている場合に空ブランチが有効だと書いてあります。&lt;/li&gt;
  &lt;li&gt;github pagesのユーザーページ。Jekyllプラグインを使用するためにソースとは別に出力HTMLだけの空ブランチを作成（Octpress方式）。&lt;/li&gt;
  &lt;li&gt;サーバーサイドプログラミングができない HTML/CSS/JS だけで作られたプロジェクト。製品版では開発版とは別のディレクトリ構造にしなければならない場合など。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;空ブランチを作成しなくても新たにリポジトリを作成するという手段もあります。実質的には同じことです。
どちらがより適切かどうかはプロジェクトによって判断する必要があると思います。&lt;/p&gt;

</description>
            <published>2012-10-26 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/git-empty-branch.html</link>
        </item>
        
        <item>
            <title>驚的速記！Notational Velocity</title>
            <description>&lt;p&gt;最近もっぱら愛用中のノートアプリ、&lt;a href=&quot;http://notational.net/&quot;&gt;Notational Velocity&lt;/a&gt;を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/nv1.png&quot; alt=&quot;nv1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notational Velocityはノートアプリとして必要最低限の機能と革新的なUIが売りです。
キーボードで操作可能なので、慣れるととても速く使うことができます。&lt;/p&gt;

&lt;p&gt;ノートアプリで重要なのは「書きたい！」と思った時にすぐ書ける、「あれどこだっけ？」という時にすぐに見つかることです。このアプリはそのどちらも実現できています。&lt;/p&gt;

&lt;p&gt;SimpleNoteやDropboxで同期できるのでクラウド環境も備えてます。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;使い方&lt;/h2&gt;

&lt;p&gt;「Cmd + L」で検索フィールドにフォーカスします。
検索フィールドに「メモ」と入力します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/nv2.png&quot; alt=&quot;nv2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Enterすると、右側のコンテンツ欄に移動します。&lt;/p&gt;

&lt;p&gt;作成ステップは&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cmd + Lで検索フィールドにフォーカス&lt;/li&gt;
  &lt;li&gt;タイトルを打って&lt;/li&gt;
  &lt;li&gt;Enter&lt;/li&gt;
  &lt;li&gt;中身を打つ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/nv3.png&quot; alt=&quot;nv3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;さて、今ここに４つの項目があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/nv4.png&quot; alt=&quot;nv4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;この状態で「メ」と打ちます&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/nv5.png&quot; alt=&quot;nv5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;すると、すべてのメモ内を全文検索します。
このままEnterを押すと「メモ」のコンテンツを入力できます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作成と検索を同じフィールドで行うことができる&lt;/strong&gt;のが素晴らしいポイント。
検索も同時に行うので重複したメモの存在を減らすことができる。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;キーボードで操作可能&lt;/h2&gt;

&lt;p&gt;たったこれだけの操作で必要なことができます。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Cmd + L&lt;/td&gt;
      &lt;td&gt;検索フィールドにフォーカス&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cmd + J&lt;/td&gt;
      &lt;td&gt;下のノートに移動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cmd + K&lt;/td&gt;
      &lt;td&gt;上のノートに移動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Tab&lt;/td&gt;
      &lt;td&gt;ノート一覧からコンテンツ欄へ移動&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cmd + R&lt;/td&gt;
      &lt;td&gt;リネーム&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + Cmd + T&lt;/td&gt;
      &lt;td&gt;タグを編集&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-2&quot;&gt;その他の機能&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;iPhoneでは &lt;a href=&quot;http://itunes.apple.com/jp/app/plaintext-dropbox-text-editing/id391254385?mt=8&quot;&gt;PlainText&lt;/a&gt; でDropboxと同期できる&lt;/li&gt;
  &lt;li&gt;フォーク版の &lt;a href=&quot;http://brettterpstra.com/project/nvalt/&quot;&gt;nvALT&lt;/a&gt; ではMarkdownプレビュー機能などがついてる&lt;/li&gt;
  &lt;li&gt;リンク機能&lt;/li&gt;
  &lt;li&gt;ブックマーク&lt;/li&gt;
  &lt;li&gt;タグ&lt;/li&gt;
  &lt;li&gt;ソート（タイトル、タグ、更新日、作成日）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;デメリット・問題点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;タイトル必須。タイトルを考えないといけない&lt;/li&gt;
  &lt;li&gt;フォルダ分けはできない&lt;/li&gt;
  &lt;li&gt;もちろん、画像は表示できない&lt;/li&gt;
  &lt;li&gt;複数端末でDropbox同期で同時に起動して使うと、いつの間にかノート消去されてる時がある。Dropboxから戻せるし、同時起動しなければ良いが、ちょっと問題。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;プレーンテキストで管理する&lt;/h2&gt;

&lt;p&gt;色々この系統のアプリを試してきましたが、Notational Velocity は自分の好みにマッチしてます。&lt;/p&gt;

&lt;p&gt;Apple Mailのメモは書く時のレスポンスは最高だけど、バグが多い。検索が遅い。
Evernoteは高機能すぎる、重い。&lt;/p&gt;

&lt;p&gt;そもそもデータがアプリケーションに依存してしまうのが怖い。
ちょっとメモを見たいだけなのに、わざわざアプリケーションを起動しなければならない。
果たして10年後、20年後もEvernoteは動いているだろうか。&lt;/p&gt;

&lt;p&gt;もっとデータを自分で管理したい。
プレーンテキストで保存しておけば、どんなソフトでも読み書きできる。スクリプトを組めば自動化や検索も簡単にできる。&lt;/p&gt;

&lt;p&gt;必要最小限で可能性無限のプレーンテキスト、その導入としてNotational Velocityは良いアプリケーションだと思います。&lt;/p&gt;

</description>
            <published>2012-10-10 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/notational-velocity.html</link>
        </item>
        
        <item>
            <title>Composer</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#composer&quot;&gt;Composerとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;とにかく始める&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#composer-1&quot;&gt;Composerを利用してオートロードを行う&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#composerjson-&quot;&gt;1. composer.json を用意&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#autoload&quot;&gt;2. autoloadファイルを生成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#autoload-1&quot;&gt;3. autoloadを読み込む&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git-composer-&quot;&gt;Gitリポジトリを Composer を利用して取得する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#composer-2&quot;&gt;プライベートなComposerリポジトリを作成する&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;公開側&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;利用側&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;リリースバージョンについて&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#repositories&quot;&gt;repositoriesについて&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;コマンド概要&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;その他&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#composerjson--1&quot;&gt;composer.json 書くのが面倒&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#alias&quot;&gt;Alias&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ssl&quot;&gt;インストールでSSLエラーが出る場合&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#composerphar&quot;&gt;composer.pharをルートに配置せずに、ディレクトリに置く&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;composer&quot;&gt;Composerとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/&quot;&gt;npm&lt;/a&gt;, &lt;a href=&quot;http://gembundler.com/&quot;&gt;bundler&lt;/a&gt;のPHP版。&lt;/p&gt;

&lt;p&gt;公式的にはパッケージ管理システムではなく、依存性管理システムだそうな &lt;a href=&quot;http://getcomposer.org/doc/00-intro.md&quot;&gt;intro&lt;/a&gt; 。
というのも、グローバルな場所にライブラリをインストールするのではなく、プロジェクト内に依存性解決した上でインストールするからだという。
まあどちらでも良いと思います。&lt;/p&gt;

&lt;p&gt;個人的に、&lt;a href=&quot;http://pear.php.net/manual/ja/installation.shared.php&quot;&gt;PEARを使ってプロジェクト内にインストールしていた&lt;/a&gt; ので
Symfonyなど有名プロジェクトが採用するほど定着した依存管理システムが出てきたのは嬉しい限りです。&lt;/p&gt;

&lt;p&gt;自分の見解ですが、用語を整理しておきます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;パッケージ：プロジェクト単位のソースコード群&lt;/li&gt;
  &lt;li&gt;リポジトリ：パッケージの集合体。パッケージの配布場所。&lt;/li&gt;
  &lt;li&gt;Composerリポジトリ: リポジトリのうち、type=composer で指定可能なリポジトリ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;とにかく始める&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s https://getcomposer.org/installer | php

# composer.jsonを作成

  &quot;require&quot;: {
    &quot;slim/slim&quot;: &quot;2.*&quot;
  }

$ php composer.phar install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アプリケーション側でautoloadを読み込むと、クラスが使用できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'vendor/autoload.php';

$slim = new \Slim\Slim;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;composer-1&quot;&gt;Composerを利用してオートロードを行う&lt;/h2&gt;

&lt;h3 id=&quot;composerjson-&quot;&gt;1. composer.json を用意&lt;/h3&gt;

&lt;p&gt;例えばこのような構成 (src ディレクトリに Acme パッケージを配置) の場合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/
|-- src
     |
     `-- Acme
          |
          `-- Hoge.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;composer.json はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# composer.json
{
  &quot;autoload&quot;: {
    &quot;psr-0&quot;: {&quot;Acme&quot;: &quot;src&quot;}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ベンダープレフィックス（例いうとAcme）を指定する必要があります。ベンダープレフィックスがないパッケージはどうするんでしょうかね。&lt;/p&gt;

&lt;h3 id=&quot;autoload&quot;&gt;2. autoloadファイルを生成&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;install&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; でもいいですが、autoload.phpを生成するだけなら、&lt;code&gt;dump-autoload&lt;/code&gt;の方が早いです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php composer.phar dump-autoload
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;autoload-1&quot;&gt;3. autoloadを読み込む&lt;/h3&gt;

&lt;p&gt;アプリケーション側で require すると自動でクラスが読み込まれるようになります（spl_autoload_registerに登録される）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
require 'vendor/autoload.php';

$obj = new \Acme\Hoge();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;git-composer-&quot;&gt;Gitリポジトリを Composer を利用して取得する&lt;/h2&gt;

&lt;p&gt;Composerに対応するためには依存する側のパッケージが&lt;code&gt;composer.json&lt;/code&gt;を含んでいる必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ライブラリ側のcomposer.json
{
  &quot;name&quot;: &quot;akkunchoi/library&quot;,
  &quot;description&quot;: &quot;composer library&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パッケージを利用する側では、Gitリポジトリのパスを指定します。&lt;code&gt;repositories&lt;/code&gt; という項目で指定されたパッケージが “require” で使えるようになります。&lt;a href=&quot;https://packagist.org/&quot;&gt;Packagist&lt;/a&gt; に登録されているパッケージは何も宣言しなくても”require” で指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ライブラリを利用する側のcomposer.json
{
  &quot;name&quot;: &quot;akkunchoi/sample&quot;,
  &quot;description&quot;: &quot;composer sample&quot;,
  &quot;repositories&quot;: [
    { &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;user@localhost:~/sample.git&quot; }
  ],
  &quot;require&quot;: {
    &quot;akkunchoi/library&quot;: &quot;1.2.x&quot;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;composer-2&quot;&gt;プライベートなComposerリポジトリを作成する&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;公開側: 
    &lt;ul&gt;
      &lt;li&gt;公開サーバー上でライブラリ一覧を作成 =&amp;gt; config.json&lt;/li&gt;
      &lt;li&gt;satisにより、パッケージ一覧を生成。パッケージ一覧をWebサーバーで公開。 =&amp;gt; プライベートCompserリポジトリ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;利用側:
    &lt;ul&gt;
      &lt;li&gt;repositoriesでプライベートComposerリポジトリを指定&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;公開側&lt;/h3&gt;

&lt;p&gt;localhostで公開してみます。自分しか見れないので公開というのも変だな。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /Users/foobar/Sites # =&amp;gt; http://localhost/ で見れるローカルファイルパス
$ mkdir composer
$ cd composer
$ curl -s https://getcomposer.org/installer | php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パッケージ一覧を生成するツール satis をインストール。&lt;code&gt;-sdev&lt;/code&gt;は&lt;code&gt;--stability=dev&lt;/code&gt;の意味です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php composer.phar create-project composer/satis -sdev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;config.jsonを作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot;: &quot;My Repository&quot;,
    &quot;homepage&quot;: &quot;http://localhost/composer/web/&quot;,
    &quot;repositories&quot;: [
        { &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;/Users/foobar/Sites/composer/hoge&quot; }
    ],
    &quot;require-all&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;name, homepage にはこの Composerリポジトリ についての情報を記述します。repositoriesにはリポジトリを指定します。
require_allは全パッケージ全バージョンを自動で取得してくれます。指定したい場合は下記のように記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;require&quot;: {
    &quot;company/package3&quot;: &quot;2.0.0&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repositoriesにこのComposerリポジトリで公開したいリポジトリを列挙します。
とりあえず今回は “Users/foobar/Sites/composer/hoge” にgitのプロジェクトを作成して、それを公開します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir hoge
$ cd hoge
$ git init
$ cp ../composer.phar .
$ php composer.phar init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init コマンドで composer.json が作成されます。内容を聞かれますがデフォルトのままで良いです。
composer.jsonを含めてコミットします。&lt;/p&gt;

&lt;p&gt;config.jsonを更新したらsatisコマンドでパッケージ一覧を生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# web/ は出力先
$ php satis/bin/satis build config.json web/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、以下の場合にもbuildが必要です。（自動化した方がいいと思います）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;パッケージの composer.json を変更する&lt;/li&gt;
  &lt;li&gt;リリースバージョンを更新する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;web内に&lt;code&gt;index.html&lt;/code&gt;と&lt;code&gt;packages.json&lt;/code&gt;が生成されます。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;利用側&lt;/h3&gt;

&lt;p&gt;利用側では &lt;code&gt;packages.json&lt;/code&gt; があるパスを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;repositories&quot;: [
        { &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http://localhost/composer/web/&quot; },
    ],
    &quot;require&quot;: {
        &quot;foobar/hoge&quot;: &quot;*&quot;,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;installすると、foobar/hoge がインストールされます。&lt;/p&gt;

&lt;p&gt;認証をかける場合..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://getcomposer.org/doc/articles/handling-private-packages-with-satis.md&quot;&gt;http://getcomposer.org/doc/articles/handling-private-packages-with-satis.md&lt;/a&gt;
&lt;a href=&quot;http://ngyuki.hatenablog.com/entry/2012/11/06/210638&quot;&gt;http://ngyuki.hatenablog.com/entry/2012/11/06/210638&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;リリースバージョンについて&lt;/h2&gt;

&lt;p&gt;ブランチは全て dev 扱いになる。バージョンっぽいブランチは&lt;code&gt;*-dev&lt;/code&gt;で、その他は&lt;code&gt;dev-*&lt;/code&gt;になる。&lt;/p&gt;

&lt;p&gt;例:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.0 =&amp;gt; 1.0.x-dev&lt;/li&gt;
  &lt;li&gt;v2.0.3 =&amp;gt; 2.0.3-dev&lt;/li&gt;
  &lt;li&gt;master =&amp;gt; dev-master&lt;/li&gt;
  &lt;li&gt;dev =&amp;gt; dev-dev&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;タグを使うといわゆる stable な指定が可能。&lt;/p&gt;

&lt;p&gt;注意点としてはcomposer.jsonでバージョンを記述することができるが、これはタグのバージョンと一致させないといけない。
わざわざcomposer.jsonでバージョン記述しなくてもいいかもしれない。&lt;/p&gt;

&lt;p&gt;利用する側でのバージョンの指定は 2.* とか * とか&lt;/p&gt;

&lt;h2 id=&quot;repositories&quot;&gt;repositoriesについて&lt;/h2&gt;

&lt;p&gt;リポジトリのtype: git, pear, package, composer, vcsなど。それぞれオプションが異なる。&lt;/p&gt;

&lt;p&gt;vcsの場合、urlにはファイルパスやsshプロトコルやgithubのパスなど。composer.json を含んでいる必要がある。&lt;/p&gt;

&lt;p&gt;composer.jsonが存在しないような既存のライブラリなどは type=package にすると良い。例えばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;type&quot;:&quot;package&quot;,
    &quot;package&quot;: {
        &quot;name&quot;: &quot;akkunchoi/php-aspectable&quot;,
        &quot;version&quot;: &quot;dev-master&quot;,
        &quot;dist&quot;: {
            &quot;url&quot;: &quot;https://github.com/akkunchoi/php-aspectable/zipball/master&quot;,
            &quot;type&quot;: &quot;zip&quot;
        },
        &quot;source&quot;: {
            &quot;url&quot;: &quot;https://github.com/akkunchoi/php-aspectable.git&quot;,
            &quot;type&quot;: &quot;git&quot;,
            &quot;reference&quot;: &quot;master&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;コマンド概要&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://getcomposer.org/doc/03-cli.md&quot;&gt;http://getcomposer.org/doc/03-cli.md&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;init&lt;/td&gt;
      &lt;td&gt;composer.jsonを作成してくれる&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;install&lt;/td&gt;
      &lt;td&gt;インストールする。lockは更新しない&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;update&lt;/td&gt;
      &lt;td&gt;composer.lockを更新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;require&lt;/td&gt;
      &lt;td&gt;composer.jsonにライブラリを追加する&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;search&lt;/td&gt;
      &lt;td&gt;パッケージの検索&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;show&lt;/td&gt;
      &lt;td&gt;パッケージの表示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;depends&lt;/td&gt;
      &lt;td&gt;依存パッケージの表示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;validate&lt;/td&gt;
      &lt;td&gt;composer.jsonの検証&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;status&lt;/td&gt;
      &lt;td&gt;状態を確認&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;create-project&lt;/td&gt;
      &lt;td&gt;外部ライブラリをするような感じ？&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dump-autoload&lt;/td&gt;
      &lt;td&gt;オートロードファイルの再生成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-5&quot;&gt;その他&lt;/h2&gt;

&lt;h3 id=&quot;composerjson--1&quot;&gt;composer.json 書くのが面倒&lt;/h3&gt;

&lt;p&gt;init で対話的に作成できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php composer.phar init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シンタックスエラーは validate でチェックできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php composer.phar validate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;composer.jsonの文法チェックとrecommendな書き方を教えてくれる。&lt;/p&gt;

&lt;p&gt;json内にはコメントが書けない(?)のがちょっとつらい。&lt;/p&gt;

&lt;h3 id=&quot;alias&quot;&gt;Alias&lt;/h3&gt;

&lt;p&gt;例えば symfony/ClassLoader はこのように設定している。
&lt;a href=&quot;https://github.com/symfony/ClassLoader/blob/master/composer.json&quot;&gt;https://github.com/symfony/ClassLoader/blob/master/composer.json&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;extra&quot;: {
    &quot;branch-alias&quot;: {
        &quot;dev-master&quot;: &quot;2.2-dev&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用者が “symfony/ClassLoader”: “2.2-dev” と指定することで、自動的に master ブランチのコードを取得させることができる。&lt;/p&gt;

&lt;h3 id=&quot;ssl&quot;&gt;インストールでSSLエラーが出る場合&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;curl: (51) SSL: certificate subject name ‘dl.packagist.org’ does not match target host name ‘getcomposer.org’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一応 https じゃなくても取得できる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s http://getcomposer.org/installer | php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;または –insecure オプションを付ける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s http://getcomposer.org/installer | php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wgetでもOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://getcomposer.org/composer.phar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;composerphar&quot;&gt;composer.pharをルートに配置せずに、ディレクトリに置く&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://getcomposer.org/installer | php -- --install-dir=bin
&lt;/code&gt;&lt;/pre&gt;

</description>
            <published>2012-10-10 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/composer.html</link>
        </item>
        
        <item>
            <title>Gitの運用方法（ブランチング）</title>
            <description>&lt;h2 id=&quot;git-flow&quot;&gt;Git-flow&lt;/h2&gt;

&lt;p&gt;Vincent Driessenさんの &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;A successful Git branching model&lt;/a&gt; (&lt;a href=&quot;http://keijinsonyaban.blogspot.jp/2010/10/successful-git-branching-model.html&quot;&gt;日本語訳&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;メインブランチ (master, develop)&lt;/li&gt;
  &lt;li&gt;サポートブランチ
    &lt;ul&gt;
      &lt;li&gt;フィーチャーブランチ&lt;/li&gt;
      &lt;li&gt;リリースブランチ (release-*)&lt;/li&gt;
      &lt;li&gt;ホットフィックスブランチ (hotfix-*)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本は２本のメインブランチ master と develop を持つ。masterは出荷可能な安定状態を保つ。develop 開発版の最新状態を保つ。&lt;/p&gt;

&lt;p&gt;develop ブランチのソースコードが安定した場合は、master ブランチにマージする。&lt;/p&gt;

&lt;p&gt;フィーチャーブランチ（トピックブランチ）は新機能を開発するためのブランチ。developから派生し、developにマージされる。&lt;/p&gt;

&lt;p&gt;マージは必ず –no-ff オプションを付ける（デフォルトにしたいができない）。&lt;/p&gt;

&lt;p&gt;リリースブランチは新しいリリースの準備をサポートする。 develop から派生し、develop や master にマージされる。リリースブランチでは新機能などの開発を行なってはいけない。master にマージして、タグ付けを行った後は削除する。&lt;/p&gt;

&lt;p&gt;ホットフィックスブランチは master から派生し、develop や master にマージする。緊急の修正を行うためのブランチ。&lt;/p&gt;

&lt;p&gt;まとめるとこのようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master ------------------------------------------------&amp;gt;
  \                          \                /   /
   \                          \--- hotfix --/    /
    \                                           /
     \                           /-- release --/
      \                         /
       \-- develop ------------------------------------&amp;gt;
             \               /
              \-- feature --/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;akkunchoi&quot;&gt;小規模プロジェクトでの運用（akkunchoi流）&lt;/h2&gt;

&lt;p&gt;最初は master ブランチしか持ちません。
即終了するかもしれないプロジェクトのために不要なブランチを作る手間を省きます。
この時点ではまだ、 master は開発版の役割です。&lt;/p&gt;

&lt;p&gt;安定版と開発版を分けたくなった段階で初めて master から dev ブランチを作成します。master は安定版で、dev を開発版とします。&lt;/p&gt;

&lt;p&gt;フィーチャーブランチはよほど大きな機能でない限りは作成しません。作成後は dev にマージします。dev がある程度安定した段階で master にマージします。&lt;/p&gt;

&lt;p&gt;ホットフィックスは master に直接コミットします。リリースブランチは作成しません。タグ付けは行います。&lt;/p&gt;

&lt;p&gt;master と dev のメインブランチが基本なのは git-flowモデルと同じです。一言で説明するとgit-flowのサポートブランチがないバージョンです。規模が大きくなってきたら git-flowモデルに移行してもいいと思います。&lt;/p&gt;

&lt;p&gt;マージする際は –no-ff 必須にします。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;その他&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/akihito_s/20111112&quot;&gt;http://d.hatena.ne.jp/akihito_s/20111112&lt;/a&gt;
&lt;a href=&quot;http://sourceforge.jp/projects/setucocms/wiki/Git%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E9%81%8B%E7%94%A8%E3%83%AB%E3%83%BC%E3%83%AB&quot;&gt;http://sourceforge.jp/projects/setucocms/wiki/Git%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E9%81%8B%E7%94%A8%E3%83%AB%E3%83%BC%E3%83%AB&lt;/a&gt;
&lt;a href=&quot;http://firn.jp/2011/05/24/git-flow&quot;&gt;http://firn.jp/2011/05/24/git-flow&lt;/a&gt;
&lt;a href=&quot;http://najeira.blogspot.jp/2012/01/git.html&quot;&gt;http://najeira.blogspot.jp/2012/01/git.html&lt;/a&gt;&lt;/p&gt;

</description>
            <published>2012-09-23 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/git-branching.html</link>
        </item>
        
        <item>
            <title>騎士カタン</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;初期配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;ダイス&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;交易品&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;都市発展&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;騎士&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;作成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;強化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;騎士のアクション&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;隣接する盗賊を動かす&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;移動&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;海賊&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot;&gt;海賊側が勝利した場合&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-12&quot;&gt;騎士側が勝利した場合&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-13&quot;&gt;発展カード&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-14&quot;&gt;緑（紙）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot;&gt;青（コイン）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot;&gt;黄（皮）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-17&quot;&gt;城塞&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-18&quot;&gt;勝利点&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-19&quot;&gt;攻略法など&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-20&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iOS版カタンに騎士カタンが追加されました。通常カタンとの違いをざっくりまとめます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://a4.mzstatic.com/us/r1000/113/Purple/v4/1e/14/89/1e1489d6-2829-fb55-4fd3-2c9722ba083d/mzl.nslmgjra.175x175-75.jpg&quot; /&gt;
&lt;a href=&quot;http://itunes.apple.com/jp/app/catan/id335029050?mt=8&amp;amp;uo=4&quot; target=&quot;itunes_store&quot;&gt;&lt;img src=&quot;http://r.mzstatic.com/images/web/linkmaker/badge_appstore-lrg.gif&quot; alt=&quot;Catan - USM&quot; style=&quot;border: 0;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;カタン島に海賊が攻めてきます。騎士を用意して海賊からの攻撃を防ぎましょう。
また、内政で都市を発展させていって特殊な効果を使い倒しましょう。&lt;/p&gt;

&lt;p&gt;サイコロ（赤、白、イベント）、交易品、騎士、海賊との戦闘、発展カードなどが通常カタンと異なる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-game.png&quot; alt=&quot;game&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;初期配置&lt;/h2&gt;

&lt;p&gt;２つ目は開拓地ではなく都市を配置します。&lt;/p&gt;

&lt;p&gt;ここで注意しなければならないのは、都市に隣接する鉄・羊・木は資源２枚もらえるのではなく、１枚は交易品になってしまうことです。交易品については後述します。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;ダイス&lt;/h2&gt;

&lt;p&gt;ダイスがひとつ増えました。数字のサイコロの一方が赤いサイコロになりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-dice.png&quot; alt=&quot;dice&quot; /&gt;&lt;/p&gt;

&lt;p&gt;右のイベントダイスは海賊３面と都市発展の各種類の３面があります。
これにより、海賊の襲撃が起きるかどうかと、どの発展カードがもらえるかどうかが決まります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-dice1.png&quot; alt=&quot;dice1&quot; /&gt;
&lt;img src=&quot;images/posts/catan-dice2.png&quot; alt=&quot;dice2&quot; /&gt;
&lt;img src=&quot;images/posts/catan-dice3.png&quot; alt=&quot;dice3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;赤いサイコロは発展カードをもらえるかどうかが、各プレイヤーの現在の都市レベルに応じて決まります。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;交易品&lt;/h2&gt;

&lt;p&gt;交易品は３種類。各資源に対応しています。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;鉄 : コイン&lt;/li&gt;
  &lt;li&gt;羊 : 皮&lt;/li&gt;
  &lt;li&gt;木 : 紙&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-trade.png&quot; alt=&quot;Trade&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例えば鉄に隣接する都市は、鉄２枚もらえる代わりに鉄１枚、コイン１枚もらいます。木ならば紙、羊ならば皮です。麦と土は通常通り２枚もらいます。&lt;/p&gt;

&lt;p&gt;交易品は資源と同様 4:1 貿易(3:1があればそれも)可能です。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;都市発展&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-cityimprovment.png&quot; alt=&quot;City Improvment&quot; /&gt;&lt;/p&gt;

&lt;p&gt;交易品は都市発展に使います。最初は１枚の交易品で１段階上昇。次は２枚で１段階、その次は３枚で、という様に最終的に５段階上げることができます。&lt;/p&gt;

&lt;p&gt;都市発展すると、対応する赤ダイスとイベントダイスが出た場合に発展カードが引けます。
例えば皮（黄色）が２段階目の場合、赤ダイス1,2,3 かつ 黄色のイベントダイスが出た場合に発展カードが引けます。&lt;/p&gt;

&lt;p&gt;また、３段階目に到達すると永続的な効果が得られます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;黄（皮）: 交易品を 2:1 貿易できる&lt;/li&gt;
  &lt;li&gt;青（コイン）: ３段階目の騎士に強化できる&lt;/li&gt;
  &lt;li&gt;緑（紙）: 7以外で、資源や交易品が取れなかったターンに好きな資源を1枚もらえる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;４段階目に到達すると、都市を大都市（メトロポリス）にすることができます。
メトロポリスにすると勝利点+2。都市の分と合わせて合計4点
メトロポリスは海賊が来ても破壊されません。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-metropolis.png&quot; alt=&quot;dice&quot; /&gt;&lt;/p&gt;

&lt;p&gt;メトロポリスは島内でその色ごとに１つしか建てることができません。
後から別のプレイヤーが５段階目にした場合は、（Longest RoadやLargest Armyと同様に）取られます。そして、５段階目以上がないため、もう奪われることがないです。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;騎士&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-knightaction.png&quot; alt=&quot;dice&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;作成&lt;/h3&gt;

&lt;p&gt;羊1枚と鉄1枚で作成できる。
騎士は開拓地のように、自分の道の空きポイントの上に配置します。開拓地は１個飛ばしにする必要があったけど、騎士はその必要ないです。開拓地の隣に騎士を配置できます。配置できる箇所がなければ、騎士を作成することはできません。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;強化&lt;/h3&gt;

&lt;p&gt;騎士にさらに羊1枚、鉄1枚与えることで強化できます。強化すると騎士力が１増えます。
最初をレベル１として、通常レベル２まで強化できます。もし、青の都市レベル３段階に到達していた場合はレベル３にできます。
１ターンにつき１回までしか強化できません。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;騎士のアクション&lt;/h3&gt;

&lt;p&gt;騎士に麦1枚与えることで、アクティブ状態にできます。何かアクションを行うと解除されます。
アクティブな騎士は海賊との戦闘で、騎士の強さにカウントされます。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;隣接する盗賊を動かす&lt;/h4&gt;

&lt;p&gt;通常カタンのナイトカードと同様。ただし、サイコロを振る前には動かすことはできない&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;移動&lt;/h4&gt;

&lt;p&gt;今いる場所から道がつながっている他の配置可能な場所に移動できます。&lt;/p&gt;

&lt;p&gt;もし自分の騎士の方が強ければ（同じ強さではできない）、他プレイヤーの騎士を追い出すことができる。
相手の騎士が他に移動可能な場所がなければ、島から取り除かなければならない。&lt;/p&gt;

&lt;p&gt;騎士は開拓地と同様に道を塞ぐこともできる。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;海賊&lt;/h2&gt;

&lt;p&gt;イベントダイスで「海賊」が出た場合、海賊コマを１進めます。
海賊が到達したら、海賊との戦闘が発生！&lt;/p&gt;

&lt;p&gt;海賊の強さは都市（または大都市）の合計数。
騎士の強さは&lt;strong&gt;アクティブになっている&lt;/strong&gt;騎士のレベルの合計数。&lt;/p&gt;

&lt;p&gt;海賊の強さ &amp;lt;= 騎士の強さ ならば 騎士側の勝利。
そうでなければ、海賊側の勝利。&lt;/p&gt;

&lt;p&gt;戦闘終了後、すべての騎士はアクティブ状態が解除されます。
もし、海賊が初めて島に来た場合、砂漠に盗賊を配置する。７と同時に来た場合は盗賊も動かす。
盗賊がいない時はバーストの処理だけ行う。&lt;/p&gt;

&lt;p&gt;海賊処理を行った後、通常のダイス処理を行う。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;海賊側が勝利した場合&lt;/h3&gt;

&lt;p&gt;最も騎士の強さが弱いプレイヤー全員、都市を開拓地にしなければならない。
もし、最も弱いプレイヤーが都市を持っていない場合は次に弱いプレイヤーが都市を壊さなければならない。
大都市しかない、開拓地しかない、すでに開拓地が５個使われてコマがない場合も破壊されない&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;騎士側が勝利した場合&lt;/h3&gt;

&lt;p&gt;最も騎士力が高いプレイヤーが単独の場合は勝利点+1
最も騎士力が高いプレイヤーが複数の場合は好きな色の発展カードを引くことができる&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;発展カード&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/catan-progresscard.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常カタンの発展カードは使いません。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;都市発展レベルと赤ダイスとイベントダイスに対応する発展カードが引ける。&lt;/li&gt;
  &lt;li&gt;今回の発展カードは一度に何枚でも使うことができる。&lt;/li&gt;
  &lt;li&gt;使ったカードは山札の一番下に戻す。&lt;/li&gt;
  &lt;li&gt;発展カードは４枚まで持つことができる。自分のターン以外で５枚になった場合は１枚捨てる。&lt;/li&gt;
  &lt;li&gt;勝利点カードはすぐ表にする。制限の４枚にはカウントしない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（括弧内はゲーム内でのカードの枚数）&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;緑（紙）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Alchemist(2): サイコロを振る前に使う。サイコロの出目を自由に決める。イベントダイスは振る&lt;/li&gt;
  &lt;li&gt;Crane(2): 都市発展に必要な交易品を１枚減らせる。重複効果なし&lt;/li&gt;
  &lt;li&gt;Engineer(1): 城塞を一つ作る&lt;/li&gt;
  &lt;li&gt;Inventor(2): 好きな２つのマスの数字を交換する。2,12,6,8は不可&lt;/li&gt;
  &lt;li&gt;Irrigation(2): 町と隣り合った麦マスx2枚の麦を得る&lt;/li&gt;
  &lt;li&gt;Medicine(2): 通常より１枚少なく都市化できる。重複効果なし&lt;/li&gt;
  &lt;li&gt;Mining(2): 町と隣り合った鉄マスx2枚の鉄を得る&lt;/li&gt;
  &lt;li&gt;Printer(1): 勝利点+1&lt;/li&gt;
  &lt;li&gt;Road Building(2): 通常カタンを同じ&lt;/li&gt;
  &lt;li&gt;Smith(2): 騎士を２つまで、１段階強化できる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-15&quot;&gt;青（コイン）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bishop(2): 盗賊を動かす。盗賊の移動先のマスに隣接するすべてのプレイヤーから１枚ずつカードを引ける&lt;/li&gt;
  &lt;li&gt;Constitution(1):　勝利点+1&lt;/li&gt;
  &lt;li&gt;Deserter(2): 騎士を持つプレイヤーを１人選ぶ。そのプレイヤーは騎士を選んで取り除く。自分は取り除かれた騎士と同じ状態、同じ強さの騎士を自分の好きなところに配置する。強騎士を取り除いた場合は自分がまだ青の都市発展レベル３をめくっていなかった場合でも強騎士を建てることができる。中騎士がすでに２体あり、中騎士を取り除いた場合は弱騎士を建てる。弱騎士も存在する場合は建てることはできない。&lt;/li&gt;
  &lt;li&gt;Diplomat(2): オープンな道を選択する。自分の道の場合はその道を取りのジテ好きなところに置く。相手の場合はその道を取り除く。&lt;/li&gt;
  &lt;li&gt;Intrigue(2): 相手プレイヤーの騎士をひとつ選ぶ。相手はその騎士を移動しなければならない。移動先がなければ島から取り除く。&lt;/li&gt;
  &lt;li&gt;Saboteur(2): 自分より勝利点が同点以上のプレイヤー全員手札を半分にする。&lt;/li&gt;
  &lt;li&gt;Spy(3): 相手プレイヤー１人の発展カードをすべて見て、好きな１枚を自分のものにする&lt;/li&gt;
  &lt;li&gt;Warlord(2): 自分の騎士をすべてアクティブ状態にする&lt;/li&gt;
  &lt;li&gt;Wedding(2): 自分より勝利点が高いプレイヤーから、資源または交易品を２枚もらう&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-16&quot;&gt;黄（皮）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Commercial Harbor(2): 相手プレイヤーそれぞれに対して、相手が交易品を持っていれば、自分は資源カードを１枚選び、相手は交易品を１枚選んで交換する&lt;/li&gt;
  &lt;li&gt;Master Merchant(2): 自分より勝利点が高いプレイヤー１人を選択。そのプレイヤーの資源・交易品手札を見て、好きな資源・交易品を２枚奪う&lt;/li&gt;
  &lt;li&gt;Merchant(6): 開拓地/都市に隣接しているマスに交易者を置く。そのコマで生産される資源を2:1貿易できる。交易者は他のプレイヤーが使った場合、移動する。交易者を持っていると勝利点+1&lt;/li&gt;
  &lt;li&gt;Merchant Fleet(2): 資源または交易品をひとつ選択。カードを使ったターン、選んだ資源または交易品で2:1貿易できる。&lt;/li&gt;
  &lt;li&gt;Resource Monopoly(4): 資源をひとつ選択。その資源を持っている他のプレイヤーからその資源を２枚ずつもらう&lt;/li&gt;
  &lt;li&gt;Trade Monopoly(2): 交易品を一つ選択。その交易品を持っている他のプレイヤーからその交易品を１枚ずつもらう&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;城塞&lt;/h2&gt;

&lt;p&gt;土2枚で都市に城塞を建てることができる。&lt;/p&gt;

&lt;p&gt;建てるとバーストにならない枚数が２枚増える。城塞は３つまで。&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;勝利点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;開拓地 +1&lt;/li&gt;
  &lt;li&gt;都市 +2&lt;/li&gt;
  &lt;li&gt;海賊との戦闘に勝利し、騎士力が単独トップ +1&lt;/li&gt;
  &lt;li&gt;青、緑発展カードの勝利点 +1&lt;/li&gt;
  &lt;li&gt;黄色の発展カードの交易者 +1&lt;/li&gt;
  &lt;li&gt;Longest Road +2&lt;/li&gt;
  &lt;li&gt;大都市 +4&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常は13点勝利&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;攻略法など&lt;/h2&gt;

&lt;p&gt;まず騎士を作成するために、羊と鉄を確保します。
次に、騎士をアクティブにするための麦を手に入れます。麦は安定して供給する必要があります。&lt;/p&gt;

&lt;p&gt;資源の2:1貿易で交易品に交換できます。土はあまり使い道がないので土の2:1は便利です。
木、鉄、羊は半分交易品になるのでなかなか増えません。&lt;/p&gt;

&lt;p&gt;黄の都市発展レベル３の好きな資源をもらえる効果は便利です。&lt;/p&gt;

&lt;p&gt;なんだかんだで、都市強化と騎士強化ができれば勝てます。&lt;/p&gt;

&lt;h2 id=&quot;section-20&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;下記ブログを参考にしました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://soudainakeikaku.blog.fc2.com/blog-entry-13.html&quot;&gt;http://soudainakeikaku.blog.fc2.com/blog-entry-13.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://soudainakeikaku.blog.fc2.com/blog-entry-20.html&quot;&gt;http://soudainakeikaku.blog.fc2.com/blog-entry-20.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://soudainakeikaku.blog.fc2.com/blog-entry-36.html&quot;&gt;http://soudainakeikaku.blog.fc2.com/blog-entry-36.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://soudainakeikaku.blog.fc2.com/blog-entry-44.html&quot;&gt;http://soudainakeikaku.blog.fc2.com/blog-entry-44.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://soudainakeikaku.blog.fc2.com/blog-entry-45.html&quot;&gt;http://soudainakeikaku.blog.fc2.com/blog-entry-45.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-09-23 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/catan-city-and-nights.html</link>
        </item>
        
        <item>
            <title>PostgreSQL</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#postgresql&quot;&gt;PostgreSQL&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#on-macosx-with-homebrew&quot;&gt;on MacOSX with homebrew&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#startstop&quot;&gt;start/stop&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#php&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#psql&quot;&gt;psql&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;postgresql&quot;&gt;PostgreSQL&lt;/h1&gt;

&lt;h2 id=&quot;on-macosx-with-homebrew&quot;&gt;on MacOSX with homebrew&lt;/h2&gt;

&lt;p&gt;インストールはhomebrewが楽。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.1.4がインストールされました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ postgres --version
postgres (PostgreSQL) 9.1.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build Notes にあれやこれやメッセージが出ます。
初回インストールの場合はデータベース作成とlaunchctl登録を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 見逃した場合は brew info で確認できる
$ brew info postgres

# If this is your first install, create a database with:
$ initdb /usr/local/var/postgres

# If this is your first install, automatically load on login with:
$ mkdir -p ~/Library/LaunchAgents
$ cp /usr/local/Cellar/postgresql/9.1.4/homebrew.mxcl.postgresql.plist ~/Library/LaunchAgents/
$ launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;startstop&quot;&gt;start/stop&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# start
$ pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start

# stop
$ pg_ctl -D /usr/local/var/postgres stop -s -m fast
pg_ctl: server does not shut down になって止められない...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;php&quot;&gt;PHP&lt;/h3&gt;

&lt;p&gt;PHPをpostgres付きでコンパイルしてなかったので再インストールする。&lt;/p&gt;

&lt;p&gt;まずは現状確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew info php
...
Installed with: --with-mysql, --with-intl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションを確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew options php
...
--with-pgsql
  Include PostgreSQL support
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;–with-pgsql オプションをつければいいみたい。&lt;/p&gt;

&lt;p&gt;一旦削除する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew uninstall php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PEARをsudoで実行したことがあるらしく、sudo付けないとuninstallできなかった&lt;/p&gt;

&lt;p&gt;pgsql付きでインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install php --with-mysql --with-intl --with-pgsql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pg_connect関数が定義されていればOK&lt;/p&gt;

&lt;h2 id=&quot;psql&quot;&gt;psql&lt;/h2&gt;

&lt;p&gt;コマンドラインツール psql の使い方。&lt;/p&gt;

&lt;p&gt;データベース一覧を確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ psql -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dbnameを指定してログイン。現在のUNIXユーザー名でログインする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ psql dbname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユーザーを指定する場合は -U オプション&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ psql dbname -U username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ログインできたらコマンドを受け付ける状態になる。
ここでは psql で使用できるコマンドやSQLが実行可能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dbname=#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表的な利用できるコマンド&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\l&lt;/td&gt;
      &lt;td&gt;データベース一覧&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\d&lt;/td&gt;
      &lt;td&gt;テーブル一覧&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\c&lt;/td&gt;
      &lt;td&gt;データベースを変更&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\q&lt;/td&gt;
      &lt;td&gt;終了&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SQLファイルを実行する場合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ psql dbname &amp;lt; hoge.sql
&lt;/code&gt;&lt;/pre&gt;

</description>
            <published>2012-08-24 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/postgres.html</link>
        </item>
        
        <item>
            <title>Apache 設定例</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;起動&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;設定例&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#php&quot;&gt;phpファイルをテキストで表示&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#php-1&quot;&gt;強制的にphpとして実行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#htaccess&quot;&gt;.htaccessを許可/禁止する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#indexhtml&quot;&gt;ディレクトリアクセスしたときにindex.htmlを表示する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#documentroot&quot;&gt;DocumentRootのディレクトリ以外を公開したい&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#alias&quot;&gt;Aliasを使う&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#virtualhost&quot;&gt;VirtualHostを使う&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;ディレクトリアクセスしたときに中身を表示しない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;シンボリックリンクをたどるのを許可する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hogehogehoge&quot;&gt;hogeをリクエストしてhogeがなければhoge.*を表示するようにする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#basic&quot;&gt;Basic認証をかける&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;他の設定ファイルを読み込む&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#php-2&quot;&gt;phpファイルだけに適用させる&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ipvirtualhost&quot;&gt;IP直打ちの場合は別のVirtualHostを表示したい&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;キャッシュクリア&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;画像等不要なファイルはアクセスログを取らないようにする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;アクセスログを日別に記録する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#php-3&quot;&gt;アクセスログに情報を追加する (PHP)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#basic-1&quot;&gt;Basic認証&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#basic-2&quot;&gt;Basic認証の仕組み&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#htpasswd-&quot;&gt;.htpasswd ファイルを作成する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#httpdconf--htaccess-&quot;&gt;httpd.conf / .htaccess での設定&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;特定のファイルには認証をかけない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip&quot;&gt;特定のIPからのアクセスには認証をかけない&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;メモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;モジュールのマニュアル&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.2/ja/mod/&quot;&gt;http://httpd.apache.org/docs/2.2/ja/mod/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;起動&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /etc/init.d/httpd restart
$ sudo /etc/init.d/httpd graceful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gracefulオプションは現在実行中のプロセスを待ってから再起動する&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;設定例&lt;/h1&gt;

&lt;h2 id=&quot;php&quot;&gt;phpファイルをテキストで表示&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;AddHandler text/plain .php
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php-1&quot;&gt;強制的にphpとして実行&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ForceType application/x-httpd-php
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;htaccess&quot;&gt;.htaccessを許可/禁止する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;AllowOverride All  # 許可
AllowOverride None # 禁止
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;indexhtml&quot;&gt;ディレクトリアクセスしたときにindex.htmlを表示する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DirectoryIndex index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;documentroot&quot;&gt;DocumentRootのディレクトリ以外を公開したい&lt;/h2&gt;

&lt;h3 id=&quot;alias&quot;&gt;Aliasを使う&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Alias /hoge &quot;/path/to/htdocs&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;virtualhost&quot;&gt;VirtualHostを使う&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost 127.0.0.1&amp;gt;
  &amp;lt;Directory /path/to/htdocs&amp;gt;
     allow from all
  &amp;lt;/Directory&amp;gt;
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;ディレクトリアクセスしたときに中身を表示しない&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Options -Indexes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示したい場合はハイフン”-“なしで&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;シンボリックリンクをたどるのを許可する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Options FollowSymLinks
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;hogehogehoge&quot;&gt;hogeをリクエストしてhogeがなければhoge.*を表示するようにする&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Options MultiViews
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic認証をかける&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;AuthType Basic
AuthName &quot;authenticate required&quot;
AuthUserFile /path/to/.htpasswd
Require valid-user
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;他の設定ファイルを読み込む&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Include /path/to/another/httpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php-2&quot;&gt;phpファイルだけに適用させる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Files ~ &quot;\.php$&quot;&amp;gt;
  ...
&amp;lt;/Files&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ipvirtualhost&quot;&gt;IP直打ちの場合は別のVirtualHostを表示したい&lt;/h2&gt;

&lt;p&gt;IP直打ちするとVirtualHostの一番最初の設定が表示される。
てきとーなやつを先頭に入れるだけでよい。&lt;/p&gt;

&lt;p&gt;VirtualHostを設定したのにIP直打ちで来る人を残念賞にする方法
&lt;a href=&quot;http://d.hatena.ne.jp/ir9Ex/20071014/1192366566&quot;&gt;http://d.hatena.ne.jp/ir9Ex/20071014/1192366566&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;キャッシュクリア&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;IfModule headers_module&amp;gt;
    &amp;lt;Files ~ &quot;\.css$&quot;&amp;gt;
    Header set Pragma no-cache
    Header set Cache-Control no-cache
    &amp;lt;/Files&amp;gt;
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;画像等不要なファイルはアクセスログを取らないようにする&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SetEnvIf Request_URI &quot;\.(gif)|(jpg)|(png)|(css)|(js)|(ico)$&quot; nolog
CustomLog &quot;/path/to/log&quot; combined env=!nolog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CustomLogで否定しないやり方も考えてみた。&lt;/p&gt;

&lt;p&gt;URIのマッチングに否定戻り読み言明を使った。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SetEnvIf Request_URI &quot;(?&amp;lt;!\.gif)(?&amp;lt;!\.jpg)(?&amp;lt;!\.png)(?&amp;lt;!\.css)(?&amp;lt;!\.js)(?&amp;lt;!\.ico)$&quot; hoge
CustomLog &quot;/path/to/log&quot; combined env=hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすれば、特定のディレクトリのみ別のログにするというのも可能&lt;/p&gt;

&lt;p&gt;（上記SetEnvIfをDirectoryディレクティブに追加すればいい）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[^\.(gif)|(jpg)]&lt;/code&gt; でいけるかなと思ったけど、文字に分解されちゃうのでダメだった。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;アクセスログを日別に記録する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CustomLog &quot;|/usr/sbin/rotatelogs /path/to/log/access.%Y%m%d.log 86400 540&quot; combined
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php-3&quot;&gt;アクセスログに情報を追加する (PHP)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://neta.ywcafe.net/000607.html&quot;&gt;http://neta.ywcafe.net/000607.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;httpd.confでLogFormatを編集&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&amp;gt;s %b %{originallog}n&quot; common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHPのapache_noteを実行する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
apache_note(&quot;originallog&quot;, $val);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えばユーザーIDなどを埋め込むと便利。&lt;/p&gt;

&lt;h1 id=&quot;basic-1&quot;&gt;Basic認証&lt;/h1&gt;

&lt;h2 id=&quot;basic-2&quot;&gt;Basic認証の仕組み&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;クライアントがページをリクエストする（この時点ではまだ認証がかかってるかどうか知らない）&lt;/li&gt;
  &lt;li&gt;クライアントに401レスポンスを返す&lt;/li&gt;
  &lt;li&gt;ユーザにIDとパスワードの入力を求める&lt;/li&gt;
  &lt;li&gt;認証ヘッダを含めてページをリクエストする&lt;/li&gt;
  &lt;li&gt;成功すれば、通常のページを。そうでなければ再度401を返す&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;htpasswd-&quot;&gt;.htpasswd ファイルを作成する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# -c ファイル新規作成
# -s パスワードをSHA1
$ htpasswd -c -s .htpasswd username
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;httpdconf--htaccess-&quot;&gt;httpd.conf / .htaccess での設定&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;AuthUserFile    /path/to/.htpasswd
AuthName        &quot;basic auth&quot;
AuthType        Basic
Require valid-user
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;特定のファイルには認証をかけない&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/core.html#satisfy&quot;&gt;Satisfy&lt;/a&gt; ディレクティブを使う。
これは、RequireとAllowが両方使われている場合に、詳細な設定を行う場合に使用する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 画像のみ認証をかけない
&amp;lt;FilesMatch &quot;\.(gif|jpe?g|png)$&quot;&amp;gt;
    Satisfy Any
    Allow from all
&amp;lt;/FilesMatch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ip&quot;&gt;特定のIPからのアクセスには認証をかけない&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Satisfy Any
Allow from 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-9&quot;&gt;メモ&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;同じパスのDirectoryディレクティブを２つ書くと、常に後に記述した方のみが適用され、前の方の設定は失われるっぽい。&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-31 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/apache.html</link>
        </item>
        
        <item>
            <title>xpdfを使ってPDFから日本語抽出</title>
            <description>&lt;p&gt;環境はMacOSX, homebrewです。&lt;/p&gt;

&lt;p&gt;homebrewでxpdfをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install xpdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動作確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pdftotext hoge.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日本語が含まれる場合、このようなエラーが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error: Unknown character collection 'Adobe-Japan1'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;調べてみると日本語用の設定が必要なようだ。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.foolabs.com/xpdf/download.html&quot;&gt;xpdf&lt;/a&gt;のサイトからLanguage Support Packagesの xpdf-japanese.tar.gz をダウンロード。&lt;/li&gt;
  &lt;li&gt;解凍したものを &lt;code&gt;/usr/local/share/xpdf/japanese&lt;/code&gt; に配置する。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;/usr/local/etc/xpdfrc&lt;/code&gt; に add-to-xpdfrc の内容を追記する。&lt;/li&gt;
  &lt;li&gt;ここまでだと、エラーはなくなるが、日本語が読み飛ばされる。textEncoding設定のコメントを外す&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;xpdfrcはこのようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# コメントを外す
textEncoding UTF-8
...
# 追記
cidToUnicode    Adobe-Japan1    /usr/local/share/xpdf/japanese/Adobe-Japan1.cidToUnicode
unicodeMap  ISO-2022-JP /usr/local/share/xpdf/japanese/ISO-2022-JP.unicodeMap
unicodeMap  EUC-JP      /usr/local/share/xpdf/japanese/EUC-JP.unicodeMap
unicodeMap  Shift-JIS   /usr/local/share/xpdf/japanese/Shift-JIS.unicodeMap
cMapDir     Adobe-Japan1    /usr/local/share/xpdf/japanese/CMap
toUnicodeDir            /usr/local/share/xpdf/japanese/CMap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上で、日本語が出力されるようになりました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://watermans-linuxtips.blogspot.jp/2008/12/pdf.html&quot;&gt;http://watermans-linuxtips.blogspot.jp/2008/12/pdf.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://oku.edu.mie-u.ac.jp/~okumura/linux/?Xpdf&quot;&gt;http://oku.edu.mie-u.ac.jp/~okumura/linux/?Xpdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/xpdf-japanese.html</link>
        </item>
        
        <item>
            <title>Test DoubleとPHPUnit</title>
            <description>&lt;h2 id=&quot;test-double&quot;&gt;Test Doubleについて&lt;/h2&gt;

&lt;p&gt;単体テストを書く時に問題になるのが、依存コンポーネントの扱いだ。例えばデータベースが必要だったり、外部サービスへの接続が必要だったりすると、テストごとに毎回セットアップしていたら途方も無い時間がかかるし、そもそも依存関係が複雑でテストができない場合もある。&lt;/p&gt;

&lt;p&gt;このような場合に、実際のオブジェクトではなく代役（Double）のオブジェクトを使うのが Test Doubleというテスト技法だ。Test Doubleにはスタブ、モック、フェイク、ダミーなど様々な手法がある。&lt;/p&gt;

&lt;p&gt;特に重要で間違いやすいのが「モック」と「スタブ」だ。英単語では「モック」は模造品、「スタブ」は切り株、切り残しという意味だが、Test Doubleにおいては「モック」は出力の確認、「スタブ」は入力の差し替えを意味する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://xunitpatterns.com/Test%20Double.html&quot;&gt;xUnit Patterns&lt;/a&gt; にTest Doubleのより詳しい解説がある。Test Doubleを使用する理由は、テスト対象オブジェクト（SUT: System Under Test）が、あるコンポーネントに依存（DOC: depended-on component）するために、「 出力を確認できない」「 入力を設定できない」「 遅い」という原因によりテストが困難になるからである。&lt;/p&gt;

&lt;h2 id=&quot;phpunit&quot;&gt;PHPUnitの例&lt;/h2&gt;

&lt;p&gt;例として、CMS的なシステムを考える。テスト対象オブジェクト Page は作成者を意味する User と永続化を行う Database に依存している。&lt;/p&gt;

&lt;p&gt;テスト対象オブジェクト&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Page{
  protected $user;
  protected $title;
  protected $body;
  protected $database;

  public function setUser($user) {
    $this-&amp;gt;user = $user;
  }

  public function setTitle($title) {
    $this-&amp;gt;title = $title;
  }

  public function setBody($body) {
    $this-&amp;gt;body = $body;
  }

  public function setDatabase(Database $database){
    $this-&amp;gt;database = $database;
  }

  public function save(){
    $s = sprintf(
      '%s wrote: &quot;%s&quot; %s', $this-&amp;gt;user-&amp;gt;getName(), $this-&amp;gt;title, $this-&amp;gt;body
    );
    $this-&amp;gt;database-&amp;gt;write($this-&amp;gt;title, $s);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存コンポーネントの Database と User&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Database{
  public function write();
}

interface User{
  public function getName();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pageのsaveメソッドをテストするには Database と User が必要である。しかし、Pageをテストするためだけなのに、わざわざ Database や User をインスタンス化する必要は全くない。User::getNameでダミーの値を返すようにしたり、 Database::write メソッドで何が与えられたか確認するだけで十分だ。&lt;/p&gt;

&lt;p&gt;PHPUnitにはモックとスタブの生成機能がある。どちらも getMock というメソッドで生成できる。テストコードはこのようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PageTest extends PHPUnit_Framework_TestCase{
  public function testSave(){
    // モック
    $dbMock = $this-&amp;gt;getMock('Database');
    $dbMock-&amp;gt;expects($this-&amp;gt;once())
            -&amp;gt;method('write')
            -&amp;gt;with($this-&amp;gt;equalTo('New Title'), $this-&amp;gt;equalTo('aaa wrote: &quot;New Title&quot; New Text'));

    // スタブ
    $userStub = $this-&amp;gt;getMock('User');
    $userStub-&amp;gt;expects($this-&amp;gt;any())
            -&amp;gt;method('getName')
            -&amp;gt;will($this-&amp;gt;returnValue('aaa'));

    // Exercise
    $page = new Page();
    $page-&amp;gt;setDatabase($dbMock);
    $page-&amp;gt;setUser($userStub);
    $page-&amp;gt;setBody('New Text');
    $page-&amp;gt;setTitle('New Title');

    // Verify
    $page-&amp;gt;save();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getMock メソッドによりモックを生成する。普通のクラスだけでなく、インタフェースでも抽象クラスでも良い。オプションでコンストラクタを実行するかどうかも制御できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$dbMock = $this-&amp;gt;getMock('Database');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;expects メソッドでどのような動作をするかをの設定を開始し、引数に何度呼ばれるべきかを設定する。&lt;code&gt;$this-&amp;gt;once()&lt;/code&gt;の他には any, never, atLeastOnce, once, exactly, at が利用できる。スタブとして生成するならコール回数の確認を行わない &lt;code&gt;$this-&amp;gt;any()&lt;/code&gt; にする。&lt;/p&gt;

&lt;p&gt;method メソッドでどのメソッドについての動作か指定する。&lt;/p&gt;

&lt;p&gt;with メソッドでexpectation を設定し、will メソッドで戻り値を設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$dbMock-&amp;gt;expects($this-&amp;gt;once())
        -&amp;gt;method('write')
        -&amp;gt;with($this-&amp;gt;equalTo('New Title'), $this-&amp;gt;equalTo('aaa wrote: &quot;New Title&quot; New Text'));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、依存コンポーネントのimplementが存在しないにもかかわらず、対象オブジェクトがテストできるというのはとても強力だ。&lt;/p&gt;

&lt;p&gt;しかしPHPUnitのモック生成機能はわかりにくい（覚えにくい）。&lt;/p&gt;

&lt;p&gt;他にもSimpleTestがモック生成機能をサポートしていたり、Mockery, Phakeといったモック生成ライブラリがあるらしいので、そのうち調べてみようと思う。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://capsctrl.que.jp/kdmsnr/wiki/bliki/?TestDouble&quot;&gt;bliki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xunitpatterns.com/Test%20Double.html&quot;&gt;xUnit Patterns&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.phpunit.de/manual/3.6/ja/test-doubles.html&quot;&gt;PHPUnit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/test-double-phpunit.html</link>
        </item>
        
        <item>
            <title>SPFを設定して迷惑メール回避する</title>
            <description>&lt;h2 id=&quot;section&quot;&gt;設定方法&lt;/h2&gt;

&lt;p&gt;TXTレコードに &lt;code&gt;v=spf1 a:example.com ~all&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;確認方法&lt;/h2&gt;

&lt;p&gt;DNSの確認はTXTレコードを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nslookup -query=TXT example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にメールヘッダを確認する。
“Received-Spf: pass” になっていれば迷惑メール回避されているはず。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ムームードメインの場合 &lt;a href=&quot;http://laugh.rinazo.com/2012/03/28/857&quot;&gt;http://laugh.rinazo.com/2012/03/28/857&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;詳しい解説 &lt;a href=&quot;http://webos-goodies.jp/archives/51103006.html&quot;&gt;http://webos-goodies.jp/archives/51103006.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;設定例 &lt;a href=&quot;http://www.au.kddi.com/service/email/support/chui/spf_record.html&quot;&gt;http://www.au.kddi.com/service/email/support/chui/spf_record.html&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/spf-dns.html</link>
        </item>
        
        <item>
            <title>teleport - Mac間でマウス、キーボード、クリップボード共有</title>
            <description>&lt;p&gt;&lt;a href=&quot;http://abyssoft.com/software/teleport/&quot;&gt;http://abyssoft.com/software/teleport/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;クリップボード共有のツールを色々探していたが見つからず。諦めかけたところ、最適なツールを発見。例えるならMacOSX版&lt;a href=&quot;http://synergy-foss.org/&quot;&gt;Synergy&lt;/a&gt;だ。&lt;/p&gt;

&lt;p&gt;マウス、キーボード共有はもちろん、クリップボード共有、ファイル共有もできる。
ホスト、クライアントの概念がなく、スムーズに設定できる。使いやすい。
KeyRemap4MacBookが入っていても問題ない。Synergyは設定が面倒だが、teleportならシステム環境設定から一瞬で設定できる。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ちなみに試してみたが満足するクオリティではなかったクリップボード共有ツールはこちら。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.theescapers.com/stuf/&quot;&gt;Stuf&lt;/a&gt; (旧Shadow)
    &lt;ul&gt;
      &lt;li&gt;有料。dropbox共有できるが、貼り付けの使い勝手がいまいち。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://itunes.apple.com/jp/app/clipbox/id448856941&quot;&gt;ClipBox&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;MacAppStoreから85円。使えない！&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pth.com/products/pthpasteboard/&quot;&gt;Pasteboard PRO&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;有料。よくわからなかった&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://itunes.apple.com/jp/app/flycut-clipboard-manager/id442160987&quot;&gt;Flycut&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;無料。dropboxへ保存はできるが、読み込みができない。貼り付けUIが良いのが惜しい。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/osx-teleport.html</link>
        </item>
        
        <item>
            <title>DatabaseException Incorrect key file for table 'mydatabase/mytable.MYI'; try to repair it</title>
            <description>&lt;p&gt;MySQLで&lt;code&gt;DELETE FROM ...&lt;/code&gt;で一行消したらDatabaseExceptionが発生してアクセスできなくった。
メッセージには &lt;code&gt;Incorrect key file for table 'mydatabase/mytable.MYI'; try to repair it&lt;/code&gt; とある。&lt;/p&gt;

&lt;p&gt;テーブルが壊れたらしいので修復する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; check table mytable;
+-----------------------------+-------+----------+----------------------------+
| Table                       | Op    | Msg_type | Msg_text                   |
+-----------------------------+-------+----------+----------------------------+
| mydatabase.mytable | check | warning  | Table is marked as crashed |
| mydatabase.mytable | check | error    | Found 426 keys of 427      |
| mydatabase.mytable | check | error    | Corrupt                    |
+-----------------------------+-------+----------+----------------------------+
3 rows in set (0.07 sec)

mysql&amp;gt; repair table mytable;
+-----------------------------+--------+----------+----------+
| Table                       | Op     | Msg_type | Msg_text |
+-----------------------------+--------+----------+----------+
| mydatabase.mytable | repair | status   | OK       |
+-----------------------------+--------+----------+----------+
1 row in set (0.14 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;check, repair はMyISAMでしか実行できないらしい。InnoDBの場合はどうなってるのだろう。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.kaburk.com/os/linux/mysql-broken.html&quot;&gt;http://blog.kaburk.com/os/linux/mysql-broken.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.livedoor.jp/roid2008/archives/50574239.html&quot;&gt;http://blog.livedoor.jp/roid2008/archives/50574239.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/myisam-incorrect-key-file-for-table-try-to-repair-it.html</link>
        </item>
        
        <item>
            <title>Chrome拡張を使ってGoogle Analyticsの自分のアクセスを除外する</title>
            <description>&lt;p&gt;IP固定の場合はIPフィルタリングすることもできるが、IP動的の場合はわざわざクッキーを設定しなければならなかった。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/jmcpbefnpobogldglnlikgojpaddibgb&quot;&gt;Analytics blocker&lt;/a&gt;はURLにマッチしたサイトへのGoogle Analyticsへの送信をブロックするChrome拡張だ。
これを使えば自分のサイトを登録するだけで、アクセスを除外できるのでとても簡単。&lt;/p&gt;

&lt;p&gt;設定は例えばこのように。
アスタリスクを忘れると、トップだけしかブロックしないので注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;akkunchoi.github.com/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ブロックできていれば、アドレスバーに赤い丸が表示される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/analytics-blocker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/jnkmfdileelhofjcijamephohjechhna&quot;&gt;Google Analytics Debugger&lt;/a&gt;を使っても確認できる。
ブロックが成功していれば、トラッキングが送信されないはずだ。&lt;/p&gt;
</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/google-analytics-exclusion-by-chrome-extension.html</link>
        </item>
        
        <item>
            <title>Apple Mail (Mail.app) がメモリをアホみたいに食う (MacOSX Snow Leopard)</title>
            <description>&lt;p&gt;Mail.appをしばらく使っていると、メモリを大量に消費するという現象にしばしば遭遇する（２年以上も前から発生してたかも）。&lt;/p&gt;

&lt;p&gt;現在の環境は MBP, OSX10.6.8, Core2Duo, メモリ4GB, Mail.app 4.5(1084)&lt;/p&gt;

&lt;p&gt;作業していると急に遅くなり、iStat Menuでメモリを見てみると Swap 8.00GB 、Mailがメモリを1.5GB以上使っている。CPUは10%程度。スワップによりHDDアクセスが増えて遅くなっているようだ。&lt;/p&gt;

&lt;p&gt;使用しているアカウントは４つ。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gmail&lt;/li&gt;
  &lt;li&gt;i.softbank.jp&lt;/li&gt;
  &lt;li&gt;gmail (google apps)&lt;/li&gt;
  &lt;li&gt;自サーバーのIMAP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アカウントの有効無効を繰り返した結果、gmailを切ると問題が発生しない。gmailは他のアカウントに比べてデータ量が半端ないのでもしかすると量も関係しているかもしれない。&lt;/p&gt;

&lt;p&gt;色々試して見つけた解決の方法は２つ。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A. 何かわからないが処理をしているようなので、放っておく。数時間かかる。&lt;/li&gt;
  &lt;li&gt;B. アカウントを無効 -&amp;gt; 有効にする。すぐ終わる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どちらかの方法を行えば、一時的に問題ない状態になる。A. の方法は時間がかかるが、なんとなくこちらの方が良い気がする。B. の方法は無理矢理だがすぐに解決できる。手順は以下の通り。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;環境設定 &amp;gt; アカウント &amp;gt; Gmailのアカウント &amp;gt; 詳細
    &lt;ul&gt;
      &lt;li&gt;このアカウントを使用のチェックを外す&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mail.appを再起動
    &lt;ul&gt;
      &lt;li&gt;問題ないことを確認&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mail.appを再起動&lt;/li&gt;
  &lt;li&gt;チェックを外したアカウントを有効にする&lt;/li&gt;
  &lt;li&gt;メモとTODOの既定アカウントにしていた場合は再設定する
    &lt;ul&gt;
      &lt;li&gt;環境設定＞作成＞メモとTODO&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ディスカッションに上がっているこれらは同じ問題だろうか。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://discussions.apple.com/thread/2003573?start=0&amp;amp;tstart=0&quot;&gt;https://discussions.apple.com/thread/2003573?start=0&amp;amp;tstart=0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://discussions.apple.com/thread/3454806?start=0&amp;amp;tstart=0&quot;&gt;https://discussions.apple.com/thread/3454806?start=0&amp;amp;tstart=0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mail.appのIMAPアクセスは不安定、Lionでも発生するらしい。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2012-10-06 追記&lt;/h2&gt;

&lt;p&gt;1ヶ月ほど前、メモ機能とGmailとの相性が悪いのではないかと考え、Mobile Meのアカウントを設定してそちらにメモを移動させた。
それと同時に、1500件ほどあったメモの内、古いメモを削除した。半分程度になった。&lt;/p&gt;

&lt;p&gt;それから1ヶ月経過したが、今のところメモリを消費する現象は発生していない。&lt;/p&gt;

</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/apple-mail-memory-problem.html</link>
        </item>
        
        <item>
            <title>Apple Mail (Mail.app) のメモをエクスポートする</title>
            <description>&lt;p&gt;Apple Mail (Mail.app) のメモは保存が早く、iPhoneと同期できて重宝していたのだけど、&lt;a href=&quot;/apple-mail-memory-problem.html&quot;&gt;変な問題&lt;/a&gt; が解決できず、別のツールに乗り換えすることを検討してみた。&lt;/p&gt;

&lt;p&gt;問題はエクスポートをどうするか。メモはgmailに保存しているので、最悪IMAPでアクセスすれば取得できるのだけど、良いスクリプトを発見。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://veritrope.com/tech/export-apple-mail-messages-and-notes-to-text-files/&quot;&gt;http://veritrope.com/tech/export-apple-mail-messages-and-notes-to-text-files/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apple MailをAppleScriptで操作してファイルに書き出すというスクリプト。
期待通り１メモが１ファイルで保存された。
これはすごい。製作者に感謝。
AppleScript習得したら色んなことができそうだ。&lt;/p&gt;

&lt;p&gt;使い方はの通り。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上記スクリプトをファイルに保存。&lt;/li&gt;
  &lt;li&gt;AppleScriptエディタで開く。&lt;/li&gt;
  &lt;li&gt;Apple Mailでエクスポートしたいメモを選択状態にして&lt;/li&gt;
  &lt;li&gt;実行する。&lt;/li&gt;
  &lt;li&gt;するとデスクトップの “Temp Export Folder” に保存される&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notational Velocityに移行する予定なため、ファイル名の連番を消す（重複する場合は付ける）ように少し書き換えた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/2847462&quot;&gt;https://gist.github.com/2847462&lt;/a&gt;&lt;/p&gt;

</description>
            <published>2012-07-28 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/apple-mail-memo-export.html</link>
        </item>
        
        <item>
            <title>wi-fiから位置情報を得る（ruby版、住所変換）</title>
            <description>&lt;p&gt;&lt;a href=&quot;http://unknownplace.org/memo/2012/07/21/1/&quot;&gt;OSX のコマンドラインから、wi-fi の情報をつかって位置情報を得る&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ruby化して、住所変換機能を付けました。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3157749.js?file=loc.rb&quot;&gt;&lt;/script&gt;

</description>
            <published>2012-07-22 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/ruby-wifi-to-address.html</link>
        </item>
        
        <item>
            <title>Rails3 routes.rb まとめ</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;ルーティングとは&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;シンプルな例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;デバッグ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#resource-routing&quot;&gt;Resource Routing&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;生成されるルート&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;基本&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#id&quot;&gt;idを伴わない場合&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#namespace---path-and-controller-prefix&quot;&gt;Namespace - path and controller prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#scope---controller-prefix&quot;&gt;Scope - controller prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#scope---path-prefix&quot;&gt;Scope - path prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nested-resources---hasmany&quot;&gt;Nested Resources - has_manyな場合に&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#member-collection---&quot;&gt;member, collection - 追加のアクション&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#collection--match&quot;&gt;collection と match&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#non-resourceful-routes&quot;&gt;Non-Resourceful Routes&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#static&quot;&gt;Static&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#query-strings&quot;&gt;query strings&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#defaults&quot;&gt;Defaults&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#naming---match&quot;&gt;Naming - matchでも名前を付ける&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#constraints-http-verb---http&quot;&gt;Constraints (HTTP verb) - HTTPメソッドで制約する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#constraints-parameter---&quot;&gt;Constraints (parameter) - パラメータを制約する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#constraints-request---&quot;&gt;Constraints (request) - リクエストで制約をする&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#advanced-constraints---&quot;&gt;Advanced Constraints - 制約クラス&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#glob&quot;&gt;glob&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redirection&quot;&gt;redirection&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rack&quot;&gt;Rack&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#root&quot;&gt;トップページ - root&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#customized-resource&quot;&gt;Customized Resource&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;設定例&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#resource--static-&quot;&gt;Resource で Static な文字列を挟みたい時&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#about--help-&quot;&gt;/about や /help のような静的ページのようなアクションを量産したい&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事はRails3のルーティングを理解するための自分用メモです。随時書き足し、整理していきます。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;ルーティングとは&lt;/h2&gt;

&lt;p&gt;まずルーティングとは何か？&lt;a href=&quot;http://guides.rubyonrails.org/routing.html&quot;&gt;公式のガイド&lt;/a&gt; にはこう書かれてます。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Rails router recognizes URLs and dispatches them to a controller’s action. It can also generate paths and URLs, avoiding the need to hardcode strings in your views.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;訳: RailsのルーターはURLを確認して、コントローラのアクションに処理を振り分けます。また、パスやURLを生成することで、ビューへのハードコードを避けることもできます。&lt;/p&gt;

&lt;p&gt;Railsのルーティングは大きく分けて２つの機能を持ちます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;URL から、「どのコントローラー」の「どのアクション」に「どういうパラメータ」を与えて処理を実行するかを定義する&lt;/li&gt;
  &lt;li&gt;ビューに URL を記述する際は、ハードコーディングを避けるためURLを直接記述せずに、専用の方法で生成する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この機能のおかげで、URL構造とアプリケーション構造を独立して設計することを可能にします。
URL構造とアプリケーション構造の橋渡しの役目が &lt;code&gt;config/routes.rb&lt;/code&gt; です。&lt;/p&gt;

&lt;p&gt;Railsではルーティングを &lt;code&gt;config/routes.rb&lt;/code&gt; に専用DSLで記述します。
Rails2とRails3ではかなり書き方が違うので注意が必要です（後方互換性はある？）。このページでは Rails3 においてのDSLを解説しています。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;シンプルな例&lt;/h2&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match &quot;/patients/:id&quot; =&amp;gt; &quot;patients#show&quot;, :as =&amp;gt; :patient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この一行の設定で「&lt;strong&gt;/patients/17&lt;/strong&gt; に HTTP GET すると、&lt;strong&gt;PatientsController の show アクションを id=17 のパラメータで実行する&lt;/strong&gt;」という設定になります。&lt;/p&gt;

&lt;p&gt;そして名前付きルート (Named Route Helper) を使用して URL を生成することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# on view..
patient_path(17) # /patients/17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;名前付きルートを使うことで、アプリケーション側ではURL構造を気にせず設計できるようになります。&lt;/p&gt;

&lt;p&gt;また、名前付きルートには path の他に url もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# on view..
patient_url(17)  # http://localhost:3000/patients/17
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;デバッグ&lt;/h2&gt;

&lt;p&gt;コンソールから &lt;code&gt;rake routes&lt;/code&gt; を実行すると、現在のルーティングの設定を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake routes
patient        /patients/:id(.:format)       patients#show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;名前付きルートを &lt;code&gt;rails console&lt;/code&gt; で試す場合は &lt;code&gt;app.patient_path&lt;/code&gt; のようにすると呼び出すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails console
[1] (main)&amp;gt; app.patient_path(17)
=&amp;gt; &quot;/patients/17&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;resource-routing&quot;&gt;Resource Routing&lt;/h2&gt;

&lt;p&gt;match を使ってアクションを定義していくのは面倒ですよね。Webアプリケーションはほとんど&lt;strong&gt;CRUD&lt;/strong&gt;の構造なので、CRUDのアクションを自動で設定できれば楽になります。Railsでは &lt;code&gt;resources&lt;/code&gt; を使って７のアクション(index, new, create, show, edit, update, destroy) を一度に設定できます。&lt;/p&gt;

&lt;p&gt;Railsのデフォルトはこの Resource Routing で、これをうまく使うことで一貫性がある構造になり、記述量も格段に減らすことができます。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;生成されるルート&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resources :photos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この一行で７つのルートが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP Verb       Path                    action       named_helper 
---------       -----                   ------       ----------
GET             /photos                 index        photos_path 
GET             /photos/new             new          new_photo_path
POST            /photos                 create       photos_path
GET             /photos/:id             show         photo_path(:id)
GET             /photos/:id/edit        edit         edit_photo_path(:id)
PUT             /photos/:id             update       photo_path(:id)
DELETE          /photos/:id             destroy      photo_path(:id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それぞれ、PhotosControllerの index, new, create, show, edit, update, destroy アクションに対応しています。&lt;/p&gt;

&lt;p&gt;newとcreate、editとupdateは対になっており、フォームと実行を想定しています。
Railsではこんな遷移を想定しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index (GET /photos)
  |
  |--&amp;gt; (GET /photos/new)      --&amp;gt; new 
  |                               |
  |                               `-- (POST /photos) --&amp;gt; create
  |
  |-- (GET /photos/:id)      --&amp;gt; show
  |
  |-- (GET /photos/:id/edit) --&amp;gt; edit 
  |                               |
  |                               `--(PUT /photos/:id)--&amp;gt; update
  |
  `-- (DELETE /photos/:id)   --&amp;gt; destroy
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;基本&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
# PhotosControllerにひもづける
resources :photos

# 複数のリソースを定義する場合は一行で書いてもOK
resources :photos, :books, :users
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;id&quot;&gt;idを伴わない場合&lt;/h3&gt;

&lt;p&gt;デフォルトでは show, edit, update, destroy は id を含むようになっています。
しかし各ユーザーのマイページのように、パラメータが不要なURLの場合もあります。&lt;/p&gt;

&lt;p&gt;その場合は resource&lt;strong&gt;s&lt;/strong&gt; ではなく、resource にします。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resource :profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:profile は複数形にしなくても、対応するコントローラは ProfilesController と複数形になるのに注意。
これは resources と同時に使う場合に、同じコントローラになった方がいいだろうという優しさらしい。&lt;/p&gt;

&lt;p&gt;resource&lt;strong&gt;s&lt;/strong&gt;と異なるのは「index がない」「:id がない」の２点。&lt;/p&gt;

&lt;p&gt;生成されるのは以下の６つのルート。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET        /profile/new      new       new_profile_path
POST       /profile          create    profile_path
GET        /profile          show      profile_path
GET        /profile/edit     edit      edit_profile_path
PUT        /profile          update    profile_path
DELETE     /profile          destroy   profile_path
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;namespace---path-and-controller-prefix&quot;&gt;Namespace - path and controller prefix&lt;/h3&gt;

&lt;p&gt;namespace は path と controller に付けられるプレフィックスです。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
namespace :admin do
  # コントローラは Admin::PhotosController です
  resources :photos
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;URLと Named helper はこうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# GET        /admin/photos      index   admin_photos_path 
# GET        /admin/photos/new  new     new_admin_photo_path
# 省略...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scope---controller-prefix&quot;&gt;Scope - controller prefix&lt;/h3&gt;

&lt;p&gt;Scope はコントローラのみプレフィックスを付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
scope :module =&amp;gt; &quot;admin&quot; do
  # コントローラは Admin::PhotosController です
  resources :photos
end

# またはこのようにも記述できます
resources :photos, :module =&amp;gt; &quot;admin&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パス、Named helperにはつかない。コントローラの構成をモジュール化したい場合に使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# GET        /photos         index      admin_photos_path 
# GET        /photos/new     new        new_admin_photo_path
# 省略...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scope---path-prefix&quot;&gt;Scope - path prefix&lt;/h3&gt;

&lt;p&gt;パスのみプレフィックスを付ける場合&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
scope &quot;/admin&quot; do    
  # コントローラは PhotosController です
  resources :photos
end

# またはこのようにも記述できます
# :path は絶対パスで
resources :photos, :path =&amp;gt; '/admin/photos'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コントローラーとNamed helperには影響しない。URLだけ変更したい場合に使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# GET        /admin/photos          index       photos_path 
# GET        /admin/photos/new      new         new_photo_path
# 省略...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、&lt;code&gt;:path&lt;/code&gt; を使えば自由にパスを変更できます。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
# :path は相対パスにする
# /hoge =&amp;gt; photo#index に対応
resources :photos, :path =&amp;gt; 'hoge' 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;nested-resources---hasmany&quot;&gt;Nested Resources - has_manyな場合に&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resources :photos do
  resources :comments
end 

# photo_comments GET /photos/:photo_id/comments     comments#index
# photo_comment  GET /photos/:photo_id/comments/:id comments#show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネストは何階層でも可能だけど、混乱をまねくため１階層以上にすべきではない。Named helperも長くなる。&lt;/p&gt;

&lt;h3 id=&quot;member-collection---&quot;&gt;member, collection - 追加のアクション&lt;/h3&gt;

&lt;p&gt;基本の7ルート以外のルートを追加したい場合は&lt;code&gt;member&lt;/code&gt;か&lt;code&gt;collection&lt;/code&gt;を使う。
&lt;code&gt;member&lt;/code&gt;は :id 付きのルートで、&lt;code&gt;collection&lt;/code&gt;は:idなしのルート。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GET /photos/:id/preview&lt;/code&gt; で preview アクションを呼ぶ設定。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resources :photos do
  member do
    get 'preview'
  end

  # または
  get 'preview', :on =&amp;gt; :member
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GET /photos/search&lt;/code&gt;で search アクションを呼ぶ設定。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resources :photos do
  collection do
    get 'search'
  end

  # または
  get 'search', :on =&amp;gt; :collection
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;collection--match&quot;&gt;collection と match&lt;/h3&gt;

&lt;p&gt;/photos/hoge, /photos/moge といちいちアクションを定義するのが面倒な場合は match を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resources :photos do
  # TODO Named helperも自動生成できないだろうか...
  # /photos/:action photos#(?-mix:[^0-9]+)
  collection do
    # 数字の場合は member アクションに流れるようにする
    match ':action', :action =&amp;gt; /[^0-9]+/
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;non-resourceful-routes&quot;&gt;Non-Resourceful Routes&lt;/h2&gt;

&lt;p&gt;resources じゃないルート。&lt;/p&gt;

&lt;h3 id=&quot;dynamic&quot;&gt;Dynamic&lt;/h3&gt;

&lt;p&gt;この設定で、&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match ':controller(/:action(/:id))'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GET /photos/show/1/2&lt;/code&gt;すると、パラメータはこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ :controller =&amp;gt; “photos”, :action =&amp;gt; “show”, :id =&amp;gt; “1”, :user_id =&amp;gt; “2” }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パラメータは自由に追加できる&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match ':controller/:action/:id/:user_id'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;namespaceの:moduleと、matchの:controllerは同時には使えない。そういう場合はこうする。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match ':controller(/:action(/:id))', :controller =&amp;gt; /admin\/[^\/]+/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;static&quot;&gt;Static&lt;/h3&gt;

&lt;p&gt;URLに特定の文字列を含むような場合。&lt;/p&gt;

&lt;p&gt;この設定で、&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match ':controller/:action/:id/with_user/:user_id'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GET /photos/show/1/with_user/2&lt;/code&gt; するとパラメータはこうなる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ :controller =&amp;gt; “photos”, :action =&amp;gt; “show”, :id =&amp;gt; “1”, :user_id =&amp;gt; “2” }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;query-strings&quot;&gt;query strings&lt;/h3&gt;

&lt;p&gt;この設定で&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match ':controller/:action/:id'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GET /photos/show/1?user_id=2&lt;/code&gt;すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ :controller =&amp;gt; “photos”, :action =&amp;gt; “show”, :id =&amp;gt; “1”, :user_id =&amp;gt; “2” }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GET /photos/show/1?id=2&lt;/code&gt; この場合はどうなるか？
&lt;code&gt;:id =&amp;gt; '1'&lt;/code&gt;になる。クエリ文字列よりも :id の方が優先されるようです。&lt;/p&gt;

&lt;h3 id=&quot;defaults&quot;&gt;Defaults&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
# GET /photos/1
# { :controller =&amp;gt; &quot;photos&quot;, :action =&amp;gt; &quot;show&quot;, :id =&amp;gt; &quot;1&quot;, :format =&amp;gt; &quot;jpg&quot;
match 'photos/:id' =&amp;gt; 'photos#show', :defaults =&amp;gt; { :format =&amp;gt; 'jpg' }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;naming---match&quot;&gt;Naming - matchでも名前を付ける&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
# logout_path, logout_url
match 'exit' =&amp;gt; 'sessions#destroy', :as =&amp;gt; :logout
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;constraints-http-verb---http&quot;&gt;Constraints (HTTP verb) - HTTPメソッドで制約する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/photos/show&lt;/code&gt;かつGETメソッドに限定する&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match 'photos/show' =&amp;gt; 'photos#show', :via =&amp;gt; :get

# 上記と下記は同じ。短縮形
get 'photos/show'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複数のメソッドを付けられます&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match 'photos/show' =&amp;gt; 'photos#show', :via =&amp;gt; [:get, :post]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;constraints-parameter---&quot;&gt;Constraints (parameter) - パラメータを制約する&lt;/h3&gt;

&lt;p&gt;こうすると&lt;code&gt;/photos/A12345&lt;/code&gt;のようなパスにマッチする。
&lt;code&gt;/photos/12&lt;/code&gt;にはマッチしない。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match 'photos/:id' =&amp;gt; 'photos#show', :constraints =&amp;gt; { :id =&amp;gt; /[A-Z]\d{5}/ }
# これは同じ意味
match 'photos/:id' =&amp;gt; 'photos#show', :id =&amp;gt; /[A-Z]\d{5}/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;制約は正規表現を受け取るが、&lt;code&gt;^ $ \b \B&lt;/code&gt;は使えない。でも先頭に固定されているので使う必要がない。&lt;/p&gt;

&lt;h3 id=&quot;constraints-request---&quot;&gt;Constraints (request) - リクエストで制約をする&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://api.rubyonrails.org/classes/ActionDispatch/Request.html&quot;&gt;ActionDispatch::Request&lt;/a&gt;オブジェクトのメソッドで制約がかけられる。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match &quot;photos&quot;, :constraints =&amp;gt; {:subdomain =&amp;gt; &quot;admin&quot;}

# ブロックを与えることもできる
namespace &quot;admin&quot; do
  constraints :subdomain =&amp;gt; &quot;admin&quot; do
    resources :photos
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;advanced-constraints---&quot;&gt;Advanced Constraints - 制約クラス&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match &quot;*path&quot; =&amp;gt; &quot;blacklist#index&quot;, :constraints =&amp;gt; BlacklistConstraint.new

class BlacklistConstraint
  def matches?(request)
    # マッチするならtrue 
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;glob&quot;&gt;glob&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match 'photos/*other' =&amp;gt; 'photos#unknown'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# GET /photos/12               :other =&amp;gt; &quot;12&quot;
# GET /photos/long/path/to/12, :other =&amp;gt; &quot;long/path/to/12&quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match 'books/*section/:title' =&amp;gt; 'books#show'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# GET /books/some/section/last-words-a-memoir
# {:section =&amp;gt; &quot;some/section&quot;, :title =&amp;gt; &quot;last-words-a-memoir&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;redirection&quot;&gt;redirection&lt;/h3&gt;

&lt;p&gt;301 “Moved Permanently” redirectになります。&lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match &quot;/stories&quot; =&amp;gt; redirect(&quot;/posts&quot;)

# 値を引き継ぐ場合
match &quot;/stories/:name&quot; =&amp;gt; redirect(&quot;/posts/%{name}&quot;)

# ブロックでもいいよ
match &quot;/stories/:name&quot; =&amp;gt; redirect {|params| &quot;/posts/#{params[:name].pluralize}&quot; }
match &quot;/stories&quot; =&amp;gt; redirect {|p, req| &quot;/posts/#{req.subdomain}&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rack&quot;&gt;Rack&lt;/h3&gt;

&lt;p&gt;TODO &lt;/p&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match &quot;/application.js&quot; =&amp;gt; Sprockets
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;root&quot;&gt;トップページ - root&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
# GET /   =&amp;gt; PagesController, 'main' action
root :to =&amp;gt; 'pages#main'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;customized-resource&quot;&gt;Customized Resource&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;設定例&lt;/h2&gt;

&lt;h3 id=&quot;resource--static-&quot;&gt;Resource で Static な文字列を挟みたい時&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
resources :users do
  member do
    match 'category/:category', :action =&amp;gt; :show, :as =&amp;gt; :category
  end
  resources :images do
    collection do
      match 'category/:category', :action =&amp;gt; :index, :as =&amp;gt; :category
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ rake routes
category_user        /users/:id/category/:category(.:format)             users#show
category_user_images /users/:user_id/images/category/:category(.:format) images#index
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;about--help-&quot;&gt;/about や /help のような静的ページのようなアクションを量産したい&lt;/h3&gt;

&lt;pre&gt;&lt;code data-language=&quot;ruby&quot;&gt;# config/routes.rb
match ':action', :controller =&amp;gt; :pages_controller
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/about は PagesController#about に、
/help は PagesController#help になります。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/willnet/20100424/1272119369&quot;&gt;http://d.hatena.ne.jp/willnet/20100424/1272119369&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://guides.rubyonrails.org/routing.html&quot;&gt;http://guides.rubyonrails.org/routing.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.usagee.co.jp/ruby/rails/RailsGuides%E3%82%92%E3%82%86%E3%81%A3%E3%81%8F%E3%82%8A%E5%92%8C%E8%A8%B3%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%E3%82%88/Rails%20Routing%20from%20the%20Outside%20In&quot;&gt;http://wiki.usagee.co.jp/ruby/rails/RailsGuides…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-20 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/rails3-routes.html</link>
        </item>
        
        <item>
            <title>CentOS に ImageMagick, RMagick のインストール</title>
            <description>&lt;p&gt;CentOS に ImageMagick と RMagick をインストールしました。CentOS 標準 yum の ImageMagick は古過ぎるそうなので、RPM,ソースからコンパイルの順でインストールしてみました。&lt;/p&gt;

&lt;h2 id=&quot;rpm--imagemagick&quot;&gt;RPM から ImageMagickをインストールするが失敗&lt;/h2&gt;

&lt;p&gt;まずは ImageMagick 公式が公開している RPM から入れてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.imagemagick.org/download/linux/CentOS/x86_64/ImageMagick-6.7.8-3.x86_64.rpm
$ sudo rpm -ivh ImageMagick-6.7.8-3.x86_64.rpm ImageMagick-6.7.8-3.x86_64.rpm

エラー: 依存性の欠如:
    libHalf.so.4()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています	libIex.so.4()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    libIlmImf.so.4()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    libImath.so.4()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    libXt.so.6()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    libfftw3.so.3()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    libgs.so.8()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    liblcms.so.1()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています	libltdl.so.3()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています	librsvg-2.so.2()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
    libwmflite-0.2.so.7()(64bit) は ImageMagick-6.7.8-3.x86_64 に必要とされています
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;libHalfってなんだよ。ソースからコンパイルする手順での成功例が多いのでそっちの方が早いかもしれない。&lt;/p&gt;

&lt;h2 id=&quot;imagemagick-&quot;&gt;ソースから ImageMagick をインストール。成功。&lt;/h2&gt;

&lt;p&gt;依存ライブラリを事前にインストール。入れてなければJPEGやPNGが変換できない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum install libjpeg-devel libpng-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.imagemagick.org/download/ImageMagick.tar.gz
$ tar zxvf ImageMagick.tar.gz
$ cd ImageMagick-6.7.8-3
$ ./configure
$ make
$ sudo make install
$ convert -list format # JPEG,PNG があればOK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;試してみる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ convert hoge.jpg hoge.png # ..OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImageMagick 6.7.8 をインストールできました。&lt;/p&gt;

&lt;p&gt;ちなみにlibjpegを入れずにコンパイルした場合、実行時にフォーマットがないというエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ convert star-off.jpg star-off.png 
convert: no decode delegate for this image format

$ convert -list format # JPEGがない
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rmagick-&quot;&gt;RMagick をインストールする&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd 適当なディレクトリ
$ vi Gemfile

source 'https://rubygems.org'
gem 'rmagick'

$ bundle install --path bundle

Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension.
 
...
 
Package MagickCore was not found in the pkg-config search path.
Perhaps you should add the directory containing `MagickCore.pc'
to the PKG_CONFIG_PATH environment variable
No package 'MagickCore' found

...

Can't install RMagick 2.13.1. Can't find MagickWand.h.
*** extconf.rb failed ***
Could not create Makefile due to some reason, probably lack of
necessary libraries and/or headers.  Check the mkmf.log file for more
details.  You may need configuration options.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PKG_CONFIG_PATH を設定しろとのこと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig

$ bundle install --path bundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドできました。&lt;/p&gt;

&lt;p&gt;試してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bundle console

irb(main):001:0&amp;gt; require &quot;RMagick&quot;
LoadError: libMagickCore.so.5: cannot open shared object file: No such file or directory - /home/admin/downloads/rmagick-test/bundle/ruby/1.9.1/gems/rmagick-2.13.1/lib/RMagick2.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shared objectが読み込めない。&lt;/p&gt;

&lt;p&gt;ダイナミックリンクライブラリのパスを設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo vi /etc/ld.so.conf

    /usr/local/lib

$ sudo /sbin/ldconfig
$ sudo /sbin/ldconfig -p | grep Magick
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでOKでした。&lt;/p&gt;

&lt;h3 id=&quot;rmagick--1&quot;&gt;RMagick インストールの参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://qiita.com/items/6b1c6c7257042a159cc9&quot;&gt;http://qiita.com/items/6b1c6c7257042a159cc9&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://6rats.blog62.fc2.com/blog-entry-78.html&quot;&gt;http://6rats.blog62.fc2.com/blog-entry-78.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;最後に&lt;/h2&gt;

&lt;p&gt;CentOS6.3 だったので yum から ImageMagick 入れられました。めでたしめでたし。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo make uninstall
$ sudo vi /etc/ld.so.conf # 変更を削除
$ sudo /sbin/ldconfig

$ sudo yum install ImageMagick ImageMagick-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImagMagick バージョンは 6.5.4.7 です。RMagick2 は 6.3.5 以上なのでインストールできます。&lt;/p&gt;

</description>
            <published>2012-07-17 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/imagemagick-rmagick-centos.html</link>
        </item>
        
        <item>
            <title>rbenv + ruby-build で ruby をインストール</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#macosx&quot;&gt;MacOSX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#centos&quot;&gt;CentOS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;macosx&quot;&gt;MacOSX&lt;/h1&gt;

&lt;p&gt;rvmからよりシンプルな構成である rbenv + ruby-build 構成に乗り換えたのでメモ。
方針として、sudoが不必要な領域にgemを格納するようにする。&lt;/p&gt;

&lt;p&gt;まずは rvm を削除。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rvm implode
# bashrc等に追加した読み込み設定を手動で削除する。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rbenv, ruby-build を homebrew でインストール。
たったの５コマンドでOK。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install rbenv
$ if which rbenv &amp;gt; /dev/null; then eval &quot;$(rbenv init -)&quot;; fi
$ brew install ruby-build
$ rbenv install 1.9.3-p194 # バージョンを指定しなければ一欄が出る
$ rbenv rehash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MacPortsでも下記CentOSの方法を使ってインストールできるかと思っていたが、上手くいかないらしい。portにruby1.9があるのでそれを使う方が良さそう。&lt;/p&gt;

&lt;h1 id=&quot;centos&quot;&gt;CentOS&lt;/h1&gt;

&lt;p&gt;CentOSにもrubyを入れる機会があったので、rbenvで入れてみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/local&lt;/code&gt;にroot権限でインストールし、ユーザー共通にする。
gemはbundlerやpassengerのみ入れる。その他はアプリケーションごとに&lt;code&gt;bundle --path=...&lt;/code&gt;で個別インストールさせる。このようにしておけば、グローバルな場所にgemライブラリをインストールする時にroot権限が必要になるのでわかりやすい。&lt;/p&gt;

&lt;p&gt;まずは必要なライブラリをインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum -y update
$ sudo yum -y install gcc kernel-devel zlib-devel openssl-devel readline-devel curl-devel libyaml-devel sqlite-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに zlib-devel がない状態でrubyをコンパイルするとこんなエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR:  Loading command: install (LoadError)
cannot load such file -- zlib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rbenvとruby-buildはgitから取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local/share
$ git clone git://github.com/sstephenson/rbenv.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/profile.d/rbenv.sh&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&quot;/usr/local/share/rbenv/bin:$PATH&quot;
export RBENV_VERSION=&quot;1.9.3-p194&quot;
export RBENV_DIR=/usr/local/share/rbenv
export RBENV_ROOT=/usr/local/share/rbenv
eval &quot;$(rbenv init -)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;権限設定して、読み込む。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 755 /etc/profile.d/rbenv.sh
$ . /etc/profile.d/rbenv.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ruby-buildのインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local/src
$ sudo git clone git://github.com/sstephenson/ruby-build.git
$ cd ruby-build
$ sudo ./install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rubyをインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rbenv install 1.9.3-p194
$ rbenv rehash
$ rbenv global 1.9.3-p194
$ gem install bundler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ロケーションとバージョンを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -v
$ which ruby
$ gem -v 
$ which gem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このままでは&lt;code&gt;sudo ruby&lt;/code&gt;や&lt;code&gt;sudo gem&lt;/code&gt;ができない。sudo時のパスが違うからだ。パスはsudoersによって管理されている。設定方法は２つある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ visudo

# env_keep設定で一般ユーザーのパスを引き継ぐようになる。
# 一般ユーザーが`/usr/local/bin`パスを設定しておけば良い
Defaults env_keep+=&quot;PATH&quot; 

# またはsecure_pathでsudo時のパスを直接指定できる（セキュリティ的にどうなんだろうか）
Defaults secure_path = &quot;/sbin:/bin:/usr/local/share/rbenv/shims:usr/local/bin:/usr/bin:&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本的なことだけど、上手くいかない場合はパスの問題であることが多い。&lt;/p&gt;

&lt;p&gt;パスの設定が間違っていると元々入っているrubyやgemやbundleが呼ばれる場合がある。
&lt;code&gt;gem env&lt;/code&gt;や&lt;code&gt;echo $PATH&lt;/code&gt;などで常にどこにgemがインストールされるか、何が優先されるのかを把握しておくと良い。
使う予定のない古いバージョンの実行ファイルは削除しておくと良い。&lt;/p&gt;

</description>
            <published>2012-07-15 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/rbenv-ruby-build.html</link>
        </item>
        
        <item>
            <title>Jekyll + github pages を使って git + markdown でサイト構築</title>
            <description>&lt;p&gt;&lt;a href=&quot;http://pages.github.com/&quot;&gt;github pages&lt;/a&gt;と&lt;a href=&quot;https://github.com/mojombo/jekyll/&quot;&gt;Jekyll&lt;/a&gt;を使って個人サイト構築してみました。今ご覧のこのページがまさにそうです。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;git + markdown でのサイト管理が便利そうなので、ホスティングまでできる&lt;a href=&quot;http://pages.github.com/&quot;&gt;github pages&lt;/a&gt;を使ってみました。&lt;/p&gt;

&lt;p&gt;ちなみに&lt;a href=&quot;http://octopress.org/&quot;&gt;Octopress&lt;/a&gt;, &lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;Jekyll bootstrap&lt;/a&gt;を使えばもっと簡単に設置できるとみたいです（後で知った）。&lt;/p&gt;

&lt;h2 id=&quot;usernamegithubcom-&quot;&gt;[username].github.com の取得&lt;/h2&gt;

&lt;p&gt;まずは github pages のユーザーページをセットアップ。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Github の &lt;a href=&quot;https://github.com/new&quot;&gt;Create a New Repo&lt;/a&gt; へ。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repository name に &lt;code&gt;[username].github.com&lt;/code&gt; と入力。[username]は自分のIDです。&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color: grey&quot;&gt;
  “username = 自分のユーザID” でない場合はドメインのルートにならず、パスを切るようです。
  例えば akkunchoi.github.com/hoge.github.com になる。
 &lt;/span&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;普通にリポジトリを作成する。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mkdir username.github.com
 cd username.github.com
 git init
 touch README
 git add README
 git commit -m 'first commit'
 git remote add origin git@github.com:username/username.github.com
 git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;リポジトリページの Admin から GitHub Pages 内の Automatic Page Generator で適当にテーマ選択。&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color: grey&quot;&gt;
   自分のユーザIDをドメインにした場合（ID: akkunchoiならakkunchoi.github.com）はGeneratorのデータが自動的にmasterにマージされたが、そうでない場合は gh-pages ブランチに作成された。
   また、README から HTML 作成ができるので、ペライチでいいなら Jekyll 使わなくてもいい。
 &lt;/span&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以上で github pages のセットアップ完了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;masterにpushすることで、自動的にデプロイされます。成功した場合は &lt;em&gt;Page Build Successful&lt;/em&gt; というGithubからの通知が来ます。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;jekyll-&quot;&gt;Jekyll を使う&lt;/h2&gt;

&lt;h3 id=&quot;jekyll--1&quot;&gt;Jekyll のインストール&lt;/h3&gt;

&lt;p&gt;HTMLを全て自分の手で書き換えるだけなら、以上でOKです。
markdownでHTML作成するためにJekyllを使用します。&lt;/p&gt;

&lt;p&gt;インストールはgemから。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初rvmで動作させていたのを忘れて、&lt;code&gt;sudo gem install jekyll&lt;/code&gt;してしまった。すると、違う場所に保存されたり、root権限になってたりでややこしいことになったが、uninstall して、&lt;code&gt;sudo&lt;/code&gt; せずに install で問題なくインストールできた。&lt;/p&gt;

&lt;h3 id=&quot;jekyll--2&quot;&gt;Jekyll 用にファイルを配置する&lt;/h3&gt;

&lt;p&gt;最低限必要なファイルは次の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/
|-- _config.yml
|-- _layouts
     `-- default.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;_config.yml の内容はこんな感じで。&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;設定オプション一欄&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto: true
server: true
markdown: kramdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当サイトの場合、default.html には Auto Generator で生成されたHTMLを元に作成しました。コンテンツ部分を &lt;code&gt;｛｛ content ｝｝&lt;/code&gt; に置き換えるだけです。（全角ブラケットを半角に…）&lt;/p&gt;

&lt;p&gt;この作業には &lt;a href=&quot;http://radiumsoftware.tumblr.com/post/10518849682&quot;&gt;Radium Software&lt;/a&gt;さんの
&lt;a href=&quot;https://github.com/unity-yb/unity-yb.github.com&quot;&gt;リポジトリ&lt;/a&gt;を参考にしました。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;ページを作成してみる&lt;/h3&gt;

&lt;p&gt;index.md を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: posts
---

## トップページです

....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;---&lt;/code&gt; で囲まれた部分はページのメタデータです。layoutは必須です。タイトル、カテゴリ、タグなども設定できます。詳細は&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML-Front-Matter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;jekyllを起動&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt; で表示できればOKです。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;公開&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;push&lt;/code&gt; するだけでOK。 Github pagesが内部でJekyllを動作させて、生成してくれます。http://[username].github.com/ で表示されていれば完了。&lt;/p&gt;

&lt;p&gt;ただ、動的な出力を行うプラグインを入れていたり、使用できない処理を入れると失敗すことがあります（Page build failure）。&lt;/p&gt;

&lt;p&gt;Octpressは、静的HTMLをローカルで生成してアップロードしている。動的な出力を行うプラグインを動作させるためにはこの方法にするか、自分でホスティングするしかなさそう。&lt;/p&gt;

&lt;h2 id=&quot;gh-pagesjekyll&quot;&gt;gh-pagesでもJekyllプラグインを使う&lt;/h2&gt;

&lt;p&gt;gh-pagesで Jekyll プラグインを使うことはできません。でもプラグインを自分のローカル環境で動作させて、生成されたHTMLファイルをアップロードすることは可能です。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;srcブランチにmarkdownファイルなどのソースを配置&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/akkunchoi/akkunchoi.github.com/blob/src/deploy&quot;&gt;deploy シェルスクリプト&lt;/a&gt; を作成。jekyllが生成した _sites を master にコピー&lt;/li&gt;
  &lt;li&gt;masterには生成後のHTMLのみ配置&lt;/li&gt;
  &lt;li&gt;masterには .nojekyll ファイルを置いて、gh-pages側で Jekyll が動作しないようにしておく。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは &lt;a href=&quot;https://github.com/akkunchoi/akkunchoi.github.com&quot;&gt;当サイトのリポジトリ&lt;/a&gt; を見てもらえれば良いかと思います。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;他わかったこと、メモ&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;_config.ymlに設定した変数はテンプレート内では site.hoge で取得できる。&lt;/li&gt;
  &lt;li&gt;layout: nil でレイアウトなし出力できる。&lt;/li&gt;
  &lt;li&gt;テンプレートエンジン &lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Designers&quot;&gt;Liquid デザイナー用マニュアル&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Liquidの raw を使用すると Page build failure （ダブルブラケットが入力できない！）。&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-07-04 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/jekyll-github-blogging.html</link>
        </item>
        
        <item>
            <title>Ruby 多次元ハッシュ</title>
            <description>&lt;p&gt;PHPでこんなことをRubyでもやりたい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a = array();
$a['foo']['bar']['fuga'] = 'hoge';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHPのノリでやるとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; a = {}
 =&amp;gt; {} 

&amp;gt; a['foo']['bar'] = 'hoge'
NoMethodError: undefined method `[]' for nil:NilClass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hashの場合、キーが存在しない場合の処理、というtrap::Hashなるものが作成できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 存在しない場合の処理をブロックで渡す
&amp;gt; a = Hash.new{ |hash,key| hash[key] = {} }
 =&amp;gt; {}
 
# foo は存在しないキーだが、ここで先ほどのブロックが発動
#   a['foo'] = {} が呼び出された後に処理が実行されるのでエラーが発生しない
# 
&amp;gt; a['foo']['bar'] = 'hoge'
 =&amp;gt; &quot;hoge&quot;
&amp;gt; a
 =&amp;gt; {&quot;foo&quot;=&amp;gt;{&quot;bar&quot;=&amp;gt;&quot;hoge&quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし多次元になる場合、Arrayの場合はめんどくさい&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruby-lang.org/ja/old-man/html/Hash.html&quot;&gt;http://www.ruby-lang.org/ja/old-man/html/Hash.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://k.try-z.com/?p=264&quot;&gt;http://k.try-z.com/?p=264&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
            <published>2012-06-29 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/ruby-multi-hash.html</link>
        </item>
        
        <item>
            <title>Gitリファレンス</title>
            <description>&lt;p&gt;gitの使い方まとめ&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#basic---ok&quot;&gt;Basic - 基本（とりあえずこれ覚えればOK）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#log---&quot;&gt;log - ログ&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#commit---amend--reset---hard-head-&quot;&gt;commit –amend や reset –hard HEAD^^ などで消えたコミットを確認する&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#commit---&quot;&gt;commit - コミット&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#git&quot;&gt;実際に削除したファイルを、git上でも削除としてステージングする&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#branch---&quot;&gt;branch - ブランチ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#merge---&quot;&gt;merge - マージ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tag---&quot;&gt;tag - タグ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#remote---&quot;&gt;remote - 共有&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#submodule---&quot;&gt;submodule - サブモジュール&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git-svn&quot;&gt;git-svn&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#git-svn-dcommit-idid&quot;&gt;git-svn dcommit できなかったのでコミットID見たら、違うIDになってた…。&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#git-svn-dcommit&quot;&gt;ローカルに未コミットの変更があるけどgit-svn-dcommitしたい&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#svnexternals&quot;&gt;svn:externalsのようなことをしたい&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;空のディレクトリはバージョン管理できない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#subversiongit&quot;&gt;複数のモジュールを含むSubversionリポジトリをGitへ移行する。&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;部分的なチェックアウトできない&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#trunk-branches-tags&quot;&gt;trunk, branches, tags&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#etc---&quot;&gt;etc - その他&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;過去のバージョンを取得、表示&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;パッチを作って適用する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;コンフリクト状態が残ってしまった場合&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mergeconflict&quot;&gt;mergeを実行したらconflictが大量に出てしまったので取り消したい&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#untracked&quot;&gt;untrackedなファイルを取り除きたい&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#merge--rebase-&quot;&gt;merge と rebase の違い&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#git-pullremote&quot;&gt;git pullでremoteを自動的に指定&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;コミットの圧縮&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;コミットを操作する&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#revert-&quot;&gt;revert コミットを打ち消す&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;basic---ok&quot;&gt;Basic - 基本（とりあえずこれ覚えればOK）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ git init hoge # git リポジトリを作成。または...
$ git clone hoge@example.com:myrepo.git # 外部から取得

... some change

$ git add *
$ git commit -m &quot;my commit&quot;
$ git status # 状態を見る
$ git push origin master  # remoteに送信
$ git pull # remoteの更新を取得
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;log---&quot;&gt;log - ログ&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ git log -p                # diffも出力する
$ git log --stat            # 変更したファイルの一覧
$ git log --pretty=oneline  #１行で
$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot; # 独自のフォーマットで
$ git log --since=2.weeks   # 日付指定
$ git log -[n]              # n件表示
$ git log --graph --oneline # ブランチ・マージ状態の確認
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;commit---amend--reset---hard-head-&quot;&gt;commit –amend や reset –hard HEAD^^ などで消えたコミットを確認する&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git reflog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HEADの移り変わりを確認できる。ブランチの移動など。reset –hardした直後なら、reflogでコミットが確認できる。&lt;/p&gt;

&lt;p&gt;この方法でも辿れなくなる場合はあるのでしょうか。&lt;/p&gt;

&lt;h2 id=&quot;commit---&quot;&gt;commit - コミット&lt;/h2&gt;

&lt;p&gt;この３手順で&lt;code&gt;svn commit&lt;/code&gt;とだいたい同じ動作になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add hoge.txt        # コミット前に `git add` でステージングが必要
$ git commit -m &quot;message&quot; # -m オプションは同じ
$ git push                # リモートに送信する
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といっても、add するのが面倒な時は -a オプションが使用できる（add済みファイルに限る）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -a hoge.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直前のコミットを書き換える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直前のコミットをなかった事にして一つ前のコミット状態に戻す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset --hard HEAD^  # HEAD^で１つ前、HEAD^^で２つ前
$ git reflog              # 間違えた場合は reflog で確認
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ステージング&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add hoge.txt
$ git add -p hoge.txt # interactiveに部分的なステージングができる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ステージングの取り消し&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset HEAD hoge.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svn revertのようなもの。ステージングしていない変更の取り消し。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -- hoge.txt
$ git checkout -- . # こうするとカレントディレクトリ以下の全更新が消えるよ
$ git checkout -p hoge.txt # interactiveに操作する
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;git&quot;&gt;実際に削除したファイルを、git上でも削除としてステージングする&lt;/h3&gt;

&lt;p&gt;Changes not staged for commit の状態がdeletedなファイルを削除してしまいたい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/git-changes-not-staged.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add -u . # -u or --update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると Changes to be committed になる&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/posts/git-changes-to-be-committed.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;branch---&quot;&gt;branch - ブランチ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://progit.org/book/ja/ch3-1.html&quot;&gt;http://progit.org/book/ja/ch3-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt;とは「あなたが作業しているローカルブランチへのポインタ」&lt;/p&gt;

&lt;p&gt;testing ブランチを作成（切り替えはしない）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切り替える&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成して切り替える&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b issue53
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;merge---&quot;&gt;merge - マージ&lt;/h2&gt;

&lt;p&gt;通常のマージはFast forward ポインタを前に進めるだけ。
&lt;a href=&quot;http://keijinsonyaban.blogspot.jp/2010/10/successful-git-branching-model.html&quot;&gt;A Successful Git branching model&lt;/a&gt;では –no-ff オプション推奨。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge issue53
$ git merge --no-commit issue53 # &quot;Merged branch ...&quot; とコミットしない
$ git merge --no-squash issue53 # 変更をワーキングツリーに適用する。
                                # マージもコミットもしない。
                                # ブランチ上での履歴は失われる。
$ git merge --no-ff issue53     # Fast forwardを行わない。    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マージを取り消す場合も通常のコミット同様&lt;code&gt;reset --hard&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset --hard HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;merge&lt;/code&gt;は二本に分かれた枝を一本に合わせる。 &lt;code&gt;rebase&lt;/code&gt;は枝が一本になるように作り直す。&lt;a href=&quot;#merge-and-rebase&quot;&gt;mergeとrebaseの違い&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるコミットの変更分だけを適用する。rebaseは連続して cherry-pick しているだけのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git cherry-pick {commit}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tag---&quot;&gt;tag - タグ&lt;/h2&gt;

&lt;p&gt;タグの一覧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;タグを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag v0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注釈付きタグの作成（コミットするかどうかの違いらしいが、どう使い分けるのかよくわかりません）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -a v1.4 -m 'my version 1.4'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;タグの共有
    $ git push origin v1.5
    $ git push origin –tags # 共有されてないもの全部
    $ git push origin :missing_tag # リモートのタグを削除&lt;/p&gt;

&lt;h2 id=&quot;remote---&quot;&gt;remote - 共有&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://progit.org/book/ja/ch3-5.html&quot;&gt;http://progit.org/book/ja/ch3-5.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;「こっちの serverfix で、リモートの awesomebranch を更新しろ」&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin serverfix:awesomebranch

$ git push origin master
$ git push                # track していれば省略できる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リモートにデータを送信&lt;/p&gt;

&lt;p&gt;「こっちの (何もなし) で、向こうの [remotebranch] を更新しろ」&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin :serverfix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ドッカーン。これでブランチはサーバーから消えてしまいました。&lt;/p&gt;

&lt;p&gt;リモートのデータを取得&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fetchしたものとマージ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;origin/serverfix が指す先から作業を開始するためのローカルブランチができあがりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b serverfix origin/serverfix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追跡ブランチ。cloneすると自動的に追跡ブランチする。これが引数なしでgit pushやgit pullが動作する理由。&lt;/p&gt;

&lt;p&gt;これは同じ意味。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout --track origin/serverfix
$ git checkout -b serverfix origin/serverfix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;push時にもセットできる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pull は fetch と merge を自動でやってくれる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull
$ git pull --rebase # mergeではなくrebaseします。
                    # ちょっとしたローカルの変更がある場合に
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リモートブランチを削除しても、別の場所してクローンされてるとずっと残る。追加は自動だけど削除は自動でしてくれない。そういう場合に prune を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 状態を確認する
$ git remote show origin
$ git remote prune origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リポジトリを破壊します！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push --force origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;submodule---&quot;&gt;submodule - サブモジュール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://progit.org/book/ja/ch6-6.html&quot;&gt;http://progit.org/book/ja/ch6-6.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;submoduleを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule add git://github.com/chneukirchen/rack.git rack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初回のみinitを実行する。updateすると、自動的にcloneされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule init
$ git submodule update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git submodule init&lt;/code&gt;を実行すると、.gitmodules が作られる。&lt;/p&gt;

&lt;p&gt;サブモジュールの外部の変更を取り込むには、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;サブモジュール内でHEADを更新して、&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上流のリポジトリでサブモジュールの変更をコミットする&lt;/p&gt;

    &lt;p&gt;$ cd rack
  $ git pull
  $ cd ..
  $ git add rack
  $ git commit -m “update submodule”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上流のリポジトリはサブモジュールのあるコミットを記録する。サブモジュールの内容が更新されたら、手動で更新を反映させなければならない。ここがsvn:externalsと異なる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git submodule update&lt;/code&gt;は上流のリポジトリが保存したポイントで、サブモジュールを再現する（チェックアウトのようなイメージ）。&lt;/p&gt;

&lt;p&gt;問題点。特定のバージョンをポイントしている（detached head）ので、git submodule updateで手元の変更が失われやすい。&lt;/p&gt;

&lt;p&gt;サブモジュールを削除&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; .git/config の該当モジュールを削除

$ git rm --cached path/to/hoge
$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;git-svn&quot;&gt;git-svn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://progit.org/book/ja/ch8-1.html&quot;&gt;http://progit.org/book/ja/ch8-1.html&lt;/a&gt;
&lt;a href=&quot;http://d.hatena.ne.jp/idesaku/20090323/1237825080&quot;&gt;http://d.hatena.ne.jp/idesaku/20090323/1237825080&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;svn checkoutのようなもの
svnからgitリポジトリを作成。 -s(standard)オプションはsvnのtrunk/branches/tags構成をそのままインポートする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git svn clone file:///tmp/test-svn -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svnのデータだけ取得&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git svn fetch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svn upのようなもの
svnのデータを取り込む&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git svn rebase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svn commitのようなもの
svnにコミット。gitのコミットIDが書き換わる！注意！
コミットできたらgit-svn-id属性が付く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git svn dcommit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git-svnで削除されたリモートブランチをローカルでも削除する方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -r -d my-remote-branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svnにブランチ作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git svn branch new_branch_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;svnにタグ作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git svn tag new_tag_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;git-svn-dcommit-idid&quot;&gt;git-svn dcommit できなかったのでコミットID見たら、違うIDになってた…。&lt;/h4&gt;

&lt;p&gt;patch を作成する&lt;/p&gt;

&lt;h4 id=&quot;git-svn-dcommit&quot;&gt;ローカルに未コミットの変更があるけどgit-svn-dcommitしたい&lt;/h4&gt;

&lt;p&gt;stashを使う&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash
$ git svn dcommit
$ git stash apply
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;svnexternals&quot;&gt;svn:externalsのようなことをしたい&lt;/h4&gt;

&lt;p&gt;git submoduleを使う。&lt;/p&gt;

&lt;p&gt;移行スクリプト。でもうまくいかなかった…&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/garbas/garbasgit.svnexternals&quot;&gt;http://github.com/garbas/garbasgit.svnexternals&lt;/a&gt;
via &lt;a href=&quot;http://d.hatena.ne.jp/Sixeight/20090210/1234272295&quot;&gt;http://d.hatena.ne.jp/Sixeight/20090210/1234272295&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;空のディレクトリはバージョン管理できない&lt;/h4&gt;

&lt;p&gt;.gitignoreとか何でもいいから空ファイルを作成すればOK。&lt;/p&gt;

&lt;h4 id=&quot;subversiongit&quot;&gt;複数のモジュールを含むSubversionリポジトリをGitへ移行する。&lt;/h4&gt;

&lt;p&gt;http://iteman.jp/blog/2009/02/subversiongit.html&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;部分的なチェックアウトできない&lt;/h4&gt;

&lt;p&gt;svn checkout はパスを指定すればどの階層でもワーキングコピーを作成できる。
git clone すると今までの履歴含め、全てをコピーしなければならない。
なのでプロジェクト/モジュールごとにリポジトリを作成するのがベストだろう。&lt;/p&gt;

&lt;p&gt;そのため、ディレクトリ同士のマージができない。これはどうにもできないかも。&lt;/p&gt;

&lt;h4 id=&quot;trunk-branches-tags&quot;&gt;trunk, branches, tags&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Subversionはディレクトリ構造として表現&lt;/li&gt;
  &lt;li&gt;Gitはbranchesとtagsが別のシステムになっている。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;etc---&quot;&gt;etc - その他&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;過去のバージョンを取得、表示&lt;/h3&gt;

&lt;p&gt;特定のファイルを特定のバージョンに戻す。commit_id はブランチやタグ名、コミットIDなど。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout commit_id path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単に表示する場合は&lt;code&gt;git show&lt;/code&gt;で。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show commit_id:path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;パッチを作って適用する&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.s21g.com/articles/680&quot;&gt;http://blog.s21g.com/articles/680&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直前のコミットとその前との差分でパッチを作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git format-patch -r HEAD~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パッチを適用する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git am 0001-hoge.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;コンフリクト状態が残ってしまった場合&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# このようなメッセージがでた場合
You have not concluded your merge (MERGE_HEAD exists).
Please, commit your changes before you can merge

$ git reset --merge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mergeconflict&quot;&gt;mergeを実行したらconflictが大量に出てしまったので取り消したい&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git reset --hard ORIG_HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;untracked&quot;&gt;untrackedなファイルを取り除きたい&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clean -f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;merge--rebase-&quot;&gt;merge と rebase の違い&lt;/h3&gt;

&lt;p&gt;masterのHEADはポイントAにあるとする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) ---A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aからブランチしたworkingを作成し、Bまで進める&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) ---A 
             \
(working)     \----- B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこからさらに masterでも変更し A’ まで進めたとする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) -- A ------------ A'
             \
(working)     \----- B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態で、&lt;/p&gt;

&lt;p&gt;(master) git merge working した場合
A’に B がマージされて C になる。
C の HEAD^（一つ前） は A’&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) ---A ------------ A' ---- C
             \                   /
(working)     \-----B------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(master) git rebase working した場合
コミットA’の存在はmasterからはなくなって、
Bからの続きとして AからA’の差分がマージされて A’’ になる
A’’ の HEAD^ は B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;First, rewinding head to replay your work on top of it...
Applying: commit B

(master) ---A         ------ A''
             \       /
(working)     \-----B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mergeはブランチの履歴を残して一本にするけど、rebaseすると履歴も含めて一本に作り直す。そのためrebaseは注意が必要。&lt;/p&gt;

&lt;h3 id=&quot;git-pullremote&quot;&gt;git pullでremoteを自動的に指定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#
# remoteが指定されてない(trackしてない)場合はリモート指定なしで git pull しても「わからないよ」と言われる
#
(master) $ git pull

You asked me to pull without telling me which branch you
want to merge with, and 'branch.master.merge' in
your configuration file does not tell me, either. Please
specify which branch you want to use on the command line and
try again (e.g. 'git pull &amp;lt;repository&amp;gt; &amp;lt;refspec&amp;gt;').
See git-pull(1) for details.

If you often merge with the same branch, you may want to
use something like the following in your configuration file:

    [branch &quot;master&quot;]
    remote = &amp;lt;nickname&amp;gt;
    merge = &amp;lt;remote-ref&amp;gt;
    
    [remote &quot;&amp;lt;nickname&amp;gt;&quot;]
    url = &amp;lt;url&amp;gt;
    fetch = &amp;lt;refspec&amp;gt;

See git-config(1) for details.

# 解決法１
# 手動で指定
#
(master) $ git pull origin master

# 解決法２
# configで指定
#
$ vi .git/config

[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master

# 解決法３
# これだけでOK
$ git push -u origin master    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;コミットの圧縮&lt;/h3&gt;

&lt;p&gt;マージするときにひとつのコミットにまとめる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git merge --squash something-new-feature
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;または git rebase -i でsquash する。（後述）&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;コミットを操作する&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# コミット２つあったとする
git commit -am &quot;hoge&quot;
git commit -am &quot;moge&quot;

git rebase -i head^^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するとエディターが開かれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick 59d6190 hoge
pick 0149644 moge

# Rebase 36fde72..0149644 onto 36fde72
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この行を修正して保存することで、指示通りにrebaseが行われる。
コマンドはコメントに書かれてある。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pick はそのままコミットを使う&lt;/li&gt;
  &lt;li&gt;reword は保存後にrebaseが走るので、その時にコミットメッセージを変更するエディタが走る。（注：rebase -i した中でのコメントを変更するのではない。）&lt;/li&gt;
  &lt;li&gt;edit はamendするためにストップする？よくわからん。&lt;/li&gt;
  &lt;li&gt;squash は一つ前のコミットと結合する。コミットメッセージはrebaseで選択する。&lt;/li&gt;
  &lt;li&gt;fixup は一つ前のコミットと結合する。コミットメッセージは前のが使われる。&lt;/li&gt;
  &lt;li&gt;exec はshellを走らせるらしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;で、行を消すとそのコミットが失われる。でも全部消すとrebaseは中止になる。&lt;/p&gt;

&lt;h3 id=&quot;revert-&quot;&gt;revert コミットを打ち消す&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git revert commit_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http://d.hatena.ne.jp/miau/20100709/1278699637&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/ja&quot;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://keijinsonyaban.blogspot.jp/2011/05/git.html&quot;&gt;Gitをボトムアップから理解する&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://keijinsonyaban.blogspot.jp/2010/10/successful-git-branching-model.html&quot;&gt;A Successful Git Branching Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            <published>2012-06-01 00:00:00 +0900</published>
            <link>http://akkunchoi.github.com/git-ref.html</link>
        </item>
        

    </channel>
</rss>
